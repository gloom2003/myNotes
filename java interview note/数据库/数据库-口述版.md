# Mysql(口述型)

## 什么是MySQL

MySQL是一个关系型数据库，它采用表的形式来存储数据。既然是表的形式存储数据，就有表结构（行和列）。行代表每一行数据，列代表该行中的每个值。列上的值是有数据类型的，比如：整数、字符串、日期等等。



## 2级 数据库的三大范式

### **第一范式1NF**

  1. 确保数据库表字段的**原子性**,即一个字段只能存放一种数据，

      

  ​	比如字段`phone number：110 13432249938`，依照第一范式必须拆分成 `家庭电话`: `110` `个人电话`:` 13432249938`两个字段。

  

### **第二范式2NF**

  1. 首先要**满足第一范式**，另外包含两部分内容，
  2. 一是表必须**有一个主键**；
  3. 二是非主键列必须**完全依赖**于主键，而不能只依赖于主键的一部分。

  举个例子。假定选课关系表为`student_course`(student_no, student_name, age, course_name, grade, credit 学分)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，**不符合第二范式，会导致数据冗余**（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题。

  应该拆分成三个表：学生：`student`(stuent_no, student_name, 年龄)；课程：`course`(course_name, credit)；选课关系：`student_course_relation`(student_no, course_name, grade)。

### **第三范式3NF**

  1. 首先要**满足第二范式**，
  2. 另外非主键列必须**直接依赖**于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。

  假定学生关系表为

  Student(student_no, student_name, age, academy_id,  academy_address,academy_telephone)，

  主键为"学号"，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。

  可以把学生关系表分为如下两个表：

  学生：(student_no, student_name, age, academy_id)；

  学院：(academy_id, academy_address,academy_telephone)。

  ### **2NF和3NF的区别？**

  - 2NF依据是非主键列是否**完全依赖**于主键(可能是联合主键)，还是依赖于主键的一部分。
  - 3NF依据是非主键列是**直接依赖**于主键，还是直接依赖于非主键



## 2级 一条查询sql语句的执行流程

 要执行SQL语句，肯定要与数据库建立连接并且具有相应的执行权限，否则就不能执行。Mysql中的连接器就是负责管理连接和进行权限校验的。

如果具有相应的权限，在Mysql8.0版本之前缓存功能还没有被删除，则会去内存中查找缓存，在缓存中能够命中的话就直接返回结果，如果没有命中缓存或者使用的是Mysql8.0之后的版本，则会走分析器来对sql进行关键字提取，比如提取出select关键字后，Mysql就知道你执行的是一条查询语句，然后进行语法分析，确认sql的语法无误后就会交给优化器来挑选Mysql认为最优的执行方案，比如选择哪一个索引、决定表的连接顺序。

当确定了执行方案后，接下来就会交给执行器准备开始执行了，执行之前还会进行一次权限验证，判断当前用户是否有执行的权限，如果没有权限，就会返回错误信息，如果有权限，才会调用存储引擎的接口来执行sql，并且把接口执行的结果进行缓存后返回。

补充：

### **要求**

* 了解查询语句执行流程



**执行 SQL 语句 select * from user where id = 1 时发生了什么**

![image-20210902082718756](D:\alwaysUse\notes\java学习资料\山哥面试专题\数据库\讲义\img\image-20210902082718756.png)

1. 连接器：负责建立连接、检查权限、连接超时时间由 wait_timeout 控制，默认 8 小时

2. 查询缓存：会将 SQL 和查询结果以键值对方式进行缓存，修改操作会以表单位导致缓存失效

3. 分析器：词法、语法分析

4. 优化器：决定用哪个索引，决定表的连接顺序等

5. 执行器：根据存储引擎类型，调用存储引擎接口

6. 存储引擎：数据的读写接口，索引、表都在此层实现



## 更新语句执行流程

更新语句执行流程如下：连接器(权限校验)----->分析器---->执行器根据索引调用存储引擎的接口寻找数据--->存储引擎找到数据后从磁盘写入内存中--->执行器从内存中获取数据进行更新操作后再调用引擎接口写入这行新数据---->引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面---->记录redo log(prepare 状态)--->执行器生成binlog--->redo log(commit 状态)

执行更新语句时也需要走一遍查询语句的执行流程，也需要连接器来管理连接与权限校验，不同的地方有:
走分析器来对sql进行关键字提取时，提取出update关键字后，Mysql就知道你执行的是一条更新语句，然后进行语法分析。

陆续经过优化器、执行器，然后调用存储引擎的接口查询数据，如果需要的数据所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回给执行器。

执行器拿到引擎给的数据后，对数据进行更新得到新的数据，再调用引擎接口刷新到磁盘中。

刷新到磁盘的操作实际上并不是直接写入到磁盘中，而是引擎先将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。执行器生成更新操作的 bin log，并把 bin log 写入磁盘。执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成commit状态，更新就算完成了。

MySQL会在系统空闲的时候根据redo log把数据写入到磁盘中，这样才真正意义上完成了数据的更新操作。

补充：

在一个表上有更新的时候，跟这个表有关的**查询缓存会失效**，所以这条语句就会把表 T 上所有缓存结果都清空。



## 事务四大特性ACID

 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）



- 原子性
  是指事务中的所有操作**要么全部成功，要么全部失败**，就像原子一样不可分割，不会出现只有部分执行成功的情况

- 一致性
  指事务在执行前后，数据库的所有数据都必须处于一致性状态。这意味着：比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000，并且事务的操作**不会破坏数据库的完整性约束**，如外键、唯一性约束等。

- 隔离性 
  
  指数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行，**事务的执行应该与其他并发事务隔离开来**。
  
- 持久性
  指**事务一旦成功提交**，其结果应该永久保存在数据库中，即使之后系统故障或重启后也不会丢失。



## 隔离级别isolation

### 3种错误现象

脏读、不可重复读、幻读。

- **脏读**是指在一个事务处理过程中读取到了其它事务未提交的数据。
- **不可重复读**是指在同一事务内，两次读取的结果不一致。
- **幻读**是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录。导致**一个事务内的读取操作的结论不能支撑之后业务的执行。**如：假设事务要新增一条记录，主键为id，在新增之前执行了select，没有发现id为6的记录，但插入id为6的数据时却出现了主键冲突，这就属于幻读，读取不到记录却发现主键冲突是因为id为6这条记录实际上已经被其他的事务插入了，但当前事务不可见。





### 4种事务隔离级别

事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。

1. Isolation.READ_UNCOMMITTED 读未提交,存在脏读、不可重复读、幻读问题

2. Isolation.READ_COMMITTED 读已提交,解决脏读问题，仍然存在不可重复读、幻读问题

3. Isolation.REPEATABLE_READ 可重复读,解决不可重复读问题，仍然存在幻读问题

4. Isolation.SERIALIZABLE 序列化,可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。

而Mysql的默认隔离级别是Repeatable read。

#### **读未提交**

* 读到其它事务未提交的数据（最新的版本）

* 错误现象：有脏读、不可重复读、幻读现象



#### **读已提交（RC）**

* 读到其它事务已提交的数据（最新已提交的版本）

* 错误现象：有不可重复读、幻读现象

* 使用场景：希望看到最新的有效值





#### **可重复读（RR）** 

* 在事务范围内，多次读能够保证一致性（快照建立时最新已提交版本）

* 错误现象：有幻读现象，可以用加锁避免

* 使用场景：事务内要求更强的一致性，但看到的未必是最新的有效值

**加锁避免幻读**

| **tx1**                                                   | **tx2**                                           |
| --------------------------------------------------------- | ------------------------------------------------- |
| set  session transaction isolation level repeatable read; |                                                   |
| start  transaction;                                       |                                                   |
| select  * from account; /*存在 1,2 两个账户*/             |                                                   |
| select  * from account where accountNo=3  for update;     |                                                   |
|                                                           | insert  into account values(3, 1000);  /* 阻塞 */ |
| insert  into account values(3, 5000);                     |                                                   |

* 在 for update 这行语句执行时，虽然此时 3 号账户尚不存在，但 MySQL 在 repeatable read 隔离级别下会用**间隙锁**，锁住 2 号记录与正无穷大之间的间隙
* 此时 tx2 想插入 3 号记录就不行了，被间隙锁挡住了



#### **序列化(串行读)** 

* 在事务范围内，仅有读读可以并发，读写或写写会阻塞其它事务，用这种办法保证更强的一致性

* 错误现象：无



**串行读避免幻读**

| **tx1**                                                | **tx2**                                           |
| ------------------------------------------------------ | ------------------------------------------------- |
| set  session transaction isolation level serializable; |                                                   |
| start  transaction;                                    |                                                   |
| select  * from account; /* 存在 1,2 两个账户 */        |                                                   |
|                                                        | insert  into account values(3, 1000);  /* 阻塞 */ |
| insert  into account values(3, 5000);                  |                                                   |

* 串行读隔离级别下，普通的 select 也会加**共享读锁**，其它事务的查询可以并发，但增删改就只能阻塞了



## 事务传播行为propagation

当**事务方法嵌套调用时**，需要控制是否开启新事务，可以使用事务传播行为来控制。

| 属性值                                                   | 行为                                                   |
| -------------------------------------------------------- | ------------------------------------------------------ |
| REQUIRED（必须要有：别人有我就进入别人的，没有就新建）   | 外层方法有事务，内层方法就加入。外层没有，内层就新建   |
| REQUIRES_NEW（必须要有新事务：不管别人有没有，我都新建） | 外层方法有事务，内层方法新建。外层没有，内层也新建     |
| SUPPORTS（支持有：别人有我就进入别人的，没有就摆了）     | 外层方法有事务，内层方法就加入。外层没有，内层就也没有 |
| NOT_SUPPORTED（支持没有:我谁也不加）                     | 外层方法有事务，内层方法没有。外层没有，内层也没有     |
| MANDATORY（强制要求外层有）                              | 外层方法有事务，内层方法加入。外层没有。内层就报错     |
| NEVER(绝不允许有)                                        | 外层方法有事务，内层方法就报错。外层没有。内层就也没有 |

**重点掌握：前三个即可**。

**(内层)事务为什么失效？**可能是事务传播行为propagation设置错误，比如设置为SUPPORTS并且此时外层方法没有设置事务时，内层的事务就会失效。



## 索引

### **要求**

* 了解常见索引与它们的适用场景，尤其是 B+Tree 索引的特点
* 掌握索引用于排序，以及失效情况
* 掌握索引用于筛选，以及失效情况
* 理解索引条件下推
* 理解二级索引覆盖

### 

### 什么是索引？

索引是存储引擎用于提高数据库表的访问速度的一种**有序的数据结构**。它就像一本字典的目录，可以帮我们快速找到对应的记录。

在MySQL中，索引可以根据单个列或多个列组合来创建的。当执行查间时，MySQL可以利用索引快速定位到满足查询条件的行，而不必扫描整个数据表。这样可以提高查询的速度，并减少数据库的负载。



### 索引的优缺点？

优点：

- **加快数据查找的速度**，降低数据库的I/O成本
- 为用来排序或者分组的字段添加索引，通过索引列对数据进行排序，可以降低数据排序的成本，可以加快分组和排序的速度
- 加快表与表之间的连接

缺点：

- 索引一般存储在磁盘的文件中，建立索引需要**占用物理空间**
- 会降低表的**增删改**的效率，因为每次对表记录进行增删改，需要进行**动态维护索引**，导致增删改时间变长



### 索引的作用

用于提高数据库表的访问速度，由于数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，磁盘I/O次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。

### 什么情况下需要建索引？



1. 针对于数据量较大（超过100多万才考虑建立索引），且**查询比较频繁，增删改比较少**的表建立索引。

2. 针对于常作为**查询条件**(where)、**排序**(order by)、**分组**(group by)操作、用于**表连接**(join)的字段建立索引，因为会被使用到，如：索引已经排好序，可以加快排序查询速度。可以加快表连接的速度

3. 尽量选择**区分度高的列**(如id)作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。

   

### 什么情况下不建索引？

1. `where`条件中用不到的字段不适合建立索引
2. 表记录较少。比如只有几百条数据，没必要加索引。
3. 需要**经常增删改**。需要评估是否适合加索引
4. **参与列计算**的列不适合建索引
5. **区分度不高**的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。



### Hash索引和B+树索引的区别？

- 哈希索引**不支持排序**，因为哈希表是无序的。
- 哈希索引**不支持范围查找**。
- 哈希索引**不支持模糊查询**及多列索引的最左前缀匹配。
- 因为哈希表中会**存在哈希冲突**，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。



### 为什么B+树比B树更适合实现数据库索引？

1. B树的每个节点都同时存储了 key 和 value ，而B+树只有叶子节点同时存储了key和value，非叶子节点不存储value只存储了key，所以可以腾出空间存储更多的key：这意味着B+树的**分叉更多，所以树的高度会更低，查询数据时磁盘I/O次数更少**，查询效率更高。
2. B+树的叶子节点使用双向链表连接：这对于**范围查询、排序极其有利**。如果需要进行一个范围查询，只需要找到范围的最小值，然后沿着叶子节点链表往后读，直到遇到范围的最大值就行了。而如果使用的是B树的话，查找范围最小值和最大值是独立的，二者没有任何关系。
3. **查询效率更稳定**：B+树只有叶子节点存储了value，所有数据的查找必须从根节点开始进行走一条从根结点到叶子节点的路。而不像B树那样，其搜索性能最好时可在顶端直接完成，最差则要寻找到叶子节点，因此，B+树的查询稳定性更好。
4. 以上的这些优势，使得InnoDB在处理大型数据时，具有良好的性能以及更高的存储效率，因此，它选择了B+树作为其索引的数据结构。



### 谈谈你对最左前缀原则的理解？

最左前缀原则是MySQL使用联合索引的一种重要原则，它决定了数据库可以如何利用索引进行查询优化。
根据该原则，如果你的查询不包含联合索引的最左部分，那么MySQL将无法利用该索引。

 ##### **order关键字的最左前缀原则**

排序字段中的第一个字段必须**以组合索引的第一个字段开头**，并且按照组合索引的顺序来看是**连续的**、**每个字段的升降序需要一致(都是ASC)**才能够使用索引。

##### where使用联合索引的条件

结论：

1. where + 模糊查询 想要走组合索引时，需要遵循字符串最左前缀原则,首先必须**出现组合索引的第一个字段**，然后like匹配的字符串的开头内容必须不是通配符（如：%）
2. where + and 想要走组合索引只要where字段中**出现组合索引的第一个字段**即可，不要求顺序，特殊情况：索引下推

##### 遇到范围查询后停止使用索引

如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。**当遇到范围查询(`>`、`<`、`between`、`like`)就会停止匹配**，后面的字段不会用到索引。

对`(a,b,c,d)`建立索引，查询条件为`a = 1 and b = 2 and c > 3 and d = 4`，那么a、b和c三个字段能用到索引，而d无法使用索引。因为遇到了范围查询。

如下图，对(a, b) 建立索引，a 在索引树中是**全局有序**的，而 b 是**全局无序，局部有序**（当a相等时，会根据b进行排序）。直接执行`b = 2`这种查询条件无法使用索引。

![最左前缀](http://img.topjavaer.cn/img/最左前缀.png)

当a的值确定的时候，b是有序的。例如`a = 1`时，b值为1，2是有序的状态。当`a = 2`时候，b的值为1，4也是有序状态。 当执行`a = 1 and b = 2`时a和b字段能用到索引。而执行`a > 1 and b = 2`时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段无法使用索引。

### 什么是索引下推

在MySQL5.6之前，存储引擎使用联合索引查询数据获得主键值，然后直接根据主键值回表查询详细信息，最后将结果返回给MySQL server层，**在server层做最后的条件判断，判断是否符合其他的查询条件**。

而在MySQL5.6及以后版本，可以使用索引下推的特性。**当存在于索引的列作为判断条件时**，MySQL server将这一部分判断条件传递给存储引擎，然后存储引擎会在回表查询之前进行条件判断，过滤掉不符合条件的索引项，然后再回表查询得到结果,最后将结果返回给MySQL server。

**有了索引下推的优化，存储引擎层会在回表查询之前对数据进行过滤，可以减少存储引擎回表查询的次数，提高查询的效率**。

### 说说索引失效的情况

##### 

1. 函数及计算问题，一旦在字段上**应用了计算或函数**，都会造成索引失效。

2. 发生**隐式类型转换**等价于在某个字段上应用了函数，造成索引失效，如字符串不加引号

3. 进行模糊查询时，如果仅仅是尾部进行**模糊匹配(like)**，索引不会失效。如果是头部进行模糊匹配(`like '%a'`)，索引则会失效。

4. 用or分割开的条件，如果**or**前的字段有索引，而后面的字段没有索引，那么涉及的索引都不会被用到。

5. 如果MySQL评估使用索引比全表更慢，则不使用索引,走全表扫描。

   如何评估？**匹配的数据占少部分则走索引比较快，占大部分则走全表扫描比较快。**

   

### 

## log 日志

### 什么是redo log?有什么用？
redo log,也被称为重做日志，是MySQL数据库中InnoDB存储引擎特有的机制。

redo log主要是用来保证事务的持久性(Durability)。

当对数据进行更新操作时，InnoDB引擎会先把记录写到redo log中，并更新内存，这个时候更新就算完成了，并不会直接写入到磁盘中。而是在适当的时候，通常是系统空闲时，将这个操作记录更新到磁盘中。

这样做的好处是，先操作内存的效率会比直接操作磁盘效率高很多，更新操作可以更快的完成，并且即使在还没有写入磁盘时数据库宕机了，只要redo log还在，就可以通过redo log把数据进行恢复，从而保证事务的一致性。

补充：

redo log是循环写的，当写到末尾时，又会从头开始写。

**redo log也是写入磁盘中，为什么会快?**

直接操作的数据页在磁盘上位置是随机的(随机I/O)，写入速度慢，redo log 的写入是顺序的速度快(顺序I/O)。

因为redo log是直接根据指针的位置继续向下写就可以了，不需要查找成本。

而更新操作需要在磁盘中进行多次I/O操作来查找数据然后再进行修改，因为磁盘的I/O操作比较耗时，所以查找成本比较大。



### 什么是undo log?有什么用？
undo log,也称为回滚日志，是MySQL数据库中InnoDB存储引擎特有的机制。

在数据库中，undo log主要有两个作用：

1. 第一个作用呢，就是提供了事务的回滚功能。当一个事务出现异常需要回滚时，InnoDB可以通过undo log把数据恢复到事务开始之前的状态。
2. 第二个作用是为实现MVCC，也就是多版本并发控制提供了一种机制。在可重复读隔离级别下，为了在事务开始时能读取到一个一致性的快照，需要通过undo log来获取数据在某个时间点的版本。

undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之
亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容
并进行回滚。

补充：

获取数据在某个时间点的版本时的相关细节：

1. 每个事务会按照开始时间，分配一个单调递增的事务编号 trx id
2. 每次事务的改动都会以行为单位记入回滚日志，包括当时的事务编号，改动的值等
3. 查询操作，事务编号大于自己的数据是不可见的，事务编号小于等于自己的数据才是可见的



## 快照读与当前读

### **要求**

* 理解快照读与当前读
* 了解快照产生的时机

表记录有两种读取方式。

- 快照读：读取的是快照版本。普通的`SELECT`就是快照读(非串行化隔离级别时)。通过mvcc(多版本并发控制)来进行并发控制的，不用加锁。
- 当前读：读取的是最新版本。`UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE`是当前读(增删改 与 特殊的查)。

#### 

### **当前读**

即读取最新提交的数据,示例：

* select … for update
* select ... lock in share mode
* insert、update、delete，都会按最新提交的数据进行操作

当前读**本质上是基于锁的并发读操作**



### 快照读

读取某一个快照建立时（可以理解为某一时间点）的数据，也称为一致性读。快照读主要体现在 **select** 时，而**不同隔离级别下，select 的行为不同**

* 在 Serializable 隔离级别下 - 普通 select 也变成当前读，即加共享读锁

* 在 RC 隔离级别下 - 每次 select 都会建立新的快照

* 在 RR 隔离级别下
  * 事务启动后，首次 select 会建立快照
  * 如果事务启动选择了 with consistent snapshot，事务启动时就建立快照
  * 基于旧数据的修改操作，会重新建立快照

快照读**本质上读取的是历史数据**（原理是回滚段），属于无锁查询



## MyISAM和InnoDB的区别？

MyISAM（my-s-摁）和InnoDB的主要区别有：

从事务来看：

 MyISAM不支持事务，没有 undo log 和 redo log。InnoDB支持事务，并且：

   * 通过 undo log 支持事务回滚（保证了事务的**原子性**）、MVCC
   * 通过两阶段提交实现一致性
   * 通过 redo log 实现事务的持久性
   * 通过MVCC、锁实现隔离性

从外键来看：

* InnoDB支持外键、非空约束,保证了数据的完整性和正确性；MyISAM则不支持

从锁来看：

* MyISAM只支持表级锁，InnoDB不仅支持表级锁，还支持行级锁，大幅度提高了多用户并发操作的性能。

从索引来看：

1. MyISAM以B树作为默认索引，MyISAM只有一种索引，被索引字段值作为普通节点的值，叶子节点还包含了该记录**数据页地址**，数据和索引是**分开存储**的。
2. 而InnoDB以B+树作为默认索引，InnoDB的索引分为**聚簇索引与二级索引**，索引和数据是**存储在一起**的。聚簇索引以主键值作为普通节点的值，叶子节点还包含了**所有字段的数据**。除主键外的其它字段建立的索引称为二级索引。以被索引的字段值作为普通节点的数据，叶子节点还包含了**主键值**

其他：

**关于总行数**：

MyISAM保存有表的总行数，如果我们需要查询表的总行数，MyISAM会直接取出保存的总行数。

而InnoDB没有保存表的总行数，需要时才会去遍历整个表，消耗相当大。

**关于全文索引：**

MyISAM支持 FULLTEXT类型的全文索引。

InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。



补充：

其他：

1. **存储结构的区别**。每个MyISAM在磁盘上存储成三个文件。文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。

   **存储空间的区别**。MyISAM支持支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

   **可移植性、备份及恢复**。MyISAM数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。对于InnoDB，可行的方案是拷贝数据文件、备份 binlog，或者用mysqldump，在数据量达到几十G的时候就相对麻烦了。

   **是否支持行级锁**。MyISAM 只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。而InnoDB 支持行级锁和表级锁，默认为行级锁。行锁大幅度提高了多用户并发操作的性能。

   **是否支持事务和崩溃后的安全恢复**。 MyISAM 不提供事务支持。而InnoDB 提供事务支持，具有事务、回滚和崩溃修复能力。

   **是否支持外键**。MyISAM不支持，而InnoDB支持。

   **是否支持MVCC**。MyISAM不支持，InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效。

   **表主键**。MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)。

   **表的行数**。MyISAM保存有表的总行数，如果`select count(*) from table`;会直接取出该值。InnoDB没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了where条件后，MyISAM和InnoDB处理的方式都一样。

   

### 要求

* 掌握 InnoDB 与 MyISAM 的主要区别
* 尤其注意它们在索引结构上的区别



## 锁

### **要求**

* 了解全局锁
* 了解表级锁
* 掌握行级锁

### MySQL有哪些锁？

MySQL主要有以下三种锁：

**按锁粒度分类**，有行级锁、表级锁和页级锁。

1. 行级锁是mysql中锁定粒度最细的一种锁。表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，能够最大程度地支持并发处理，但加锁的开销也最大。
   行级锁的类型主要有三类：
   -  Record Lock，记录锁，也就是仅仅把一条记录锁上；
   -  Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
   -  Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

2. 表级锁是mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。它会锁定整个表，让其他所有的DML、DDL操作和可能读取不同版本数据的读操作等待，直到锁被释放。例如，当对一张表进行写操作时，需要对其加表锁，这期间其他任何人都无法对表进行修改，可以进行读取。

3. 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，它锁定的是数据库的某一"页"，这个"页"中包含了相邻的很多行。

这三种锁各有优缺点:

- 表锁开销小，加锁快，不会出现死锁，锁定粒度大，发生冲突的概率最高，并发度最低。
- 行锁开销大，加锁慢，会出现死锁，锁定粒度小，发生冲突的概率最低，并发度也最高。

- 页锁侧介于两者之间。





### 全局锁是什么？

**全局锁就是对整个数据库实例加锁。**使用全局读锁锁定所有数据库的所有表。**让整个库处于只读状态，**这时会阻塞其它线程所有 DML写语句 以及 DDL 操作，DQL语句仍然可以执行，其典型的应用场景是做全库的逻辑备份时，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

### 表级锁

#### 
