# Mysql(口述型)

## 什么是MySQL

MySQL是一个关系型数据库，它采用表的形式来存储数据。既然是表的形式存储数据，就有表结构（行和列）。行代表每一行数据，列代表该行中的每个值。列上的值是有数据类型的，比如：整数、字符串、日期等等。



## 2级 数据库的三大范式

### **第一范式1NF**

  1. 确保数据库表字段的**原子性**,即一个字段只能存放一种数据，

      

  ​	比如字段`phone number：110 13432249938`，依照第一范式必须拆分成 `家庭电话`: `110` `个人电话`:` 13432249938`两个字段。

  

### **第二范式2NF**

  1. 首先要**满足第一范式**，另外包含两部分内容，
  2. 一是表必须**有一个主键**；
  3. 二是非主键列必须**完全依赖**于主键，而不能只依赖于主键的一部分。

  举个例子。假定选课关系表为`student_course`(student_no, student_name, age, course_name, grade, credit 学分)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，**不符合第二范式，会导致数据冗余**（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题。

  应该拆分成三个表：学生：`student`(stuent_no, student_name, 年龄)；课程：`course`(course_name, credit)；选课关系：`student_course_relation`(student_no, course_name, grade)。

### **第三范式3NF**

  1. 首先要**满足第二范式**，
  2. 另外非主键列必须**直接依赖**于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。

  假定学生关系表为

  Student(student_no, student_name, age, academy_id,  academy_address,academy_telephone)，

  主键为"学号"，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。

  可以把学生关系表分为如下两个表：

  学生：(student_no, student_name, age, academy_id)；

  学院：(academy_id, academy_address,academy_telephone)。

  ### **2NF和3NF的区别？**

  - 2NF依据是非主键列是否**完全依赖**于主键(可能是联合主键)，还是依赖于主键的一部分。
  - 3NF依据是非主键列是**直接依赖**于主键，还是直接依赖于非主键



## 2级 一条查询sql语句的执行流程

查询语句的执行流程如下：权限校验(连接器)--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎

 要执行SQL语句，肯定要与数据库建立连接并且具有相应的执行权限，否则就不能执行。Mysql中的连接器就是负责管理连接和进行权限校验的。

如果具有相应的权限，在Mysql8.0版本之前缓存功能还没有被删除，则会去内存中查找缓存，在缓存中能够命中的话就直接返回结果，如果没有命中缓存或者使用的是Mysql8.0之后的版本，则会走分析器来对sql进行关键字提取，比如提取出select关键字后，Mysql就知道你执行的是一条查询语句，然后进行语法分析，确认sql的语法无误后就会交给优化器来挑选Mysql认为最优的执行方案，比如选择哪一个索引。

当确定了执行方案后，接下来就会交给执行器准备开始执行了，执行之前还会进行一次权限验证，判断当前用户是否有执行的权限，如果没有权限，就会返回错误信息，如果有权限，才会调用存储引擎的接口来执行sql，并且把接口执行的结果进行缓存后返回。



## 更新语句执行流程

更新语句执行流程如下：连接器(权限校验)----->分析器---->执行器根据索引调用存储引擎的接口寻找数据--->存储引擎找到数据后从磁盘写入内存中--->执行器从内存中获取数据进行更新操作后再调用引擎接口写入这行新数据---->引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面---->记录redo log(prepare 状态)--->执行器生成binlog--->redo log(commit 状态)

执行更新语句时也需要走一遍查询语句的执行流程，也需要连接器来管理连接与权限校验，不同的地方有:
走分析器来对sql进行关键字提取时，提取出update关键字后，Mysql就知道你执行的是一条更新语句，然后进行语法分析。

陆续经过优化器、执行器，然后调用存储引擎的接口查询数据，如果需要的数据所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回给执行器。

执行器拿到引擎给的数据后，对数据进行更新得到新的数据，再调用引擎接口刷新到磁盘中。

刷新到磁盘的操作实际上并不是直接写入到磁盘中，而是引擎先将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。执行器生成更新操作的 bin log，并把 bin log 写入磁盘。执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成commit状态，更新就算完成了。

MySQL会在系统空闲的时候根据redo log把数据写入到磁盘中，这样才真正意义上完成了数据的更新操作。

补充：

在一个表上有更新的时候，跟这个表有关的**查询缓存会失效**，所以这条语句就会把表 T 上所有缓存结果都清空。



## 事务四大特性ACID

 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）



- 原子性
  是指事务中的所有操作要么全部成功，要么全部失败，就像原子一样不可分割，不会出现只有部分执行成功的情况

- 一致性
  指事务在执行前后，数据库必须保持一致的状态。这意味着事务的操作不会破坏数据库的完整性约束，如外键、唯一性约束等。

- 隔离性 
  
  指事务的执行应该与其他并发事务隔离开来，每个事务对其他事务的感知程度是由隔离级别决定的。隔离级别定义了事
  务之间的可见性和影响，包括读未提交、读已提交、可重复读和串行化。

- 持久性
  指**事务一旦成功提交**，其结果应该永久保存在数据库中，即使之后系统故障或重启后也不会丢失。



## 隔离级别isolation

### 3种错误现象

脏读、不可重复读、幻读。

- **脏读**是指在一个事务处理过程中读取到了其它事务未提交的数据。
- **不可重复读**是指在同一事务内，两次读取的结果不一致。
- **幻读**是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录。导致**一个事务内的读取操作的结论不能支撑之后业务的执行。**如：假设事务要新增一条记录，主键为id，在新增之前执行了select，没有发现id为6的记录，但插入id为6的数据时却出现了主键冲突，这就属于幻读，读取不到记录却发现主键冲突是因为id为6这条记录实际上已经被其他的事务插入了，但当前事务不可见。





### 4种事务隔离级别

事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。

1. Isolation.READ_UNCOMMITTED 读未提交,存在脏读、不可重复读、幻读问题

2. Isolation.READ_COMMITTED 读已提交,解决脏读问题，仍然存在不可重复读、幻读问题

3. Isolation.REPEATABLE_READ 可重复读,解决不可重复读问题，仍然存在幻读问题

4. Isolation.SERIALIZABLE 序列化,可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。

而Mysql的默认隔离级别是Repeatable read。

#### **读未提交**

* 读到其它事务未提交的数据（最新的版本）

* 错误现象：有脏读、不可重复读、幻读现象



#### **读已提交（RC）**

* 读到其它事务已提交的数据（最新已提交的版本）

* 错误现象：有不可重复读、幻读现象

* 使用场景：希望看到最新的有效值





#### **可重复读（RR）** 

* 在事务范围内，多次读能够保证一致性（快照建立时最新已提交版本）

* 错误现象：有幻读现象，可以用加锁避免

* 使用场景：事务内要求更强的一致性，但看到的未必是最新的有效值

**加锁避免幻读**

| **tx1**                                                   | **tx2**                                           |
| --------------------------------------------------------- | ------------------------------------------------- |
| set  session transaction isolation level repeatable read; |                                                   |
| start  transaction;                                       |                                                   |
| select  * from account; /*存在 1,2 两个账户*/             |                                                   |
| select  * from account where accountNo=3  for update;     |                                                   |
|                                                           | insert  into account values(3, 1000);  /* 阻塞 */ |
| insert  into account values(3, 5000);                     |                                                   |

* 在 for update 这行语句执行时，虽然此时 3 号账户尚不存在，但 MySQL 在 repeatable read 隔离级别下会用**间隙锁**，锁住 2 号记录与正无穷大之间的间隙
* 此时 tx2 想插入 3 号记录就不行了，被间隙锁挡住了



#### **序列化(串行读)** 

* 在事务范围内，仅有读读可以并发，读写或写写会阻塞其它事务，用这种办法保证更强的一致性

* 错误现象：无



**串行读避免幻读**

| **tx1**                                                | **tx2**                                           |
| ------------------------------------------------------ | ------------------------------------------------- |
| set  session transaction isolation level serializable; |                                                   |
| start  transaction;                                    |                                                   |
| select  * from account; /* 存在 1,2 两个账户 */        |                                                   |
|                                                        | insert  into account values(3, 1000);  /* 阻塞 */ |
| insert  into account values(3, 5000);                  |                                                   |

* 串行读隔离级别下，普通的 select 也会加**共享读锁**，其它事务的查询可以并发，但增删改就只能阻塞了



## 事务传播行为propagation

当**事务方法嵌套调用时**，需要控制是否开启新事务，可以使用事务传播行为来控制。

| 属性值                                                   | 行为                                                   |
| -------------------------------------------------------- | ------------------------------------------------------ |
| REQUIRED（必须要有：别人有我就进入别人的，没有就新建）   | 外层方法有事务，内层方法就加入。外层没有，内层就新建   |
| REQUIRES_NEW（必须要有新事务：不管别人有没有，我都新建） | 外层方法有事务，内层方法新建。外层没有，内层也新建     |
| SUPPORTS（支持有：别人有我就进入别人的，没有就摆了）     | 外层方法有事务，内层方法就加入。外层没有，内层就也没有 |
| NOT_SUPPORTED（支持没有:我谁也不加）                     | 外层方法有事务，内层方法没有。外层没有，内层也没有     |
| MANDATORY（强制要求外层有）                              | 外层方法有事务，内层方法加入。外层没有。内层就报错     |
| NEVER(绝不允许有)                                        | 外层方法有事务，内层方法就报错。外层没有。内层就也没有 |

**重点掌握：前三个即可**。

**(内层)事务为什么失效？**可能是事务传播行为propagation设置错误，比如设置为SUPPORTS并且此时外层方法没有设置事务时，内层的事务就会失效。



## 索引

### 什么是索引？

索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。它可以比作一本字典的目录，可以帮你快速找到对应的记录。

索引一般存储在磁盘的文件中，它是占用物理空间的。

### 索引的优缺点？

优点：

- **加快数据查找的速度**
- 为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度
- 加快表与表之间的连接

缺点：

- 建立索引需要**占用物理空间**
- 会降低表的**增删改**的效率，因为每次对表记录进行增删改，需要进行**动态维护索引**，导致增删改时间变长

### 索引的作用

数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。

### 什么情况下需要建索引？

1. 经常用于**查询**的字段
2. 经常用于**连接**的字段建立索引，可以加快连接的速度
3. 经常需要**排序**的字段建立索引，因为索引已经排好序，可以加快排序查询速度

### 什么情况下不建索引？

1. `where`条件中用不到的字段不适合建立索引
2. 表记录较少。比如只有几百条数据，没必要加索引。
3. 需要经常增删改。需要评估是否适合加索引
4. **参与列计算**的列不适合建索引
5. **区分度不高**的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。



### Hash索引和B+树索引的区别？

- 哈希索引**不支持排序**，因为哈希表是无序的。
- 哈希索引**不支持范围查找**。
- 哈希索引**不支持模糊查询**及多列索引的最左前缀匹配。
- 因为哈希表中会**存在哈希冲突**，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。



## log 日志

### 什么是redo log?有什么用？
redo log,也被称为重做日志，是MySQL数据库中InnoDB存储引擎特有的机制。

redo log主要是用来保证事务的持久性(Durability)。

当对数据进行更新操作时，InnoDB引擎会先把记录写到redo log中，并更新内存，这个时候更新就算完成了，并不会直接写入到磁盘中。而是在适当的时候，通常是系统空闲时，将这个操作记录更新到磁盘中。

这样做的好处是，先操作内存的效率会比直接操作磁盘效率高很多，更新操作可以更快的完成，并且即使在还没有写入磁盘时数据库宕机了，只要redo log还在，就可以通过redo log把数据进行恢复，从而保证事务的一致性。

补充：

redo log是循环写的，当写到末尾时，又会从头开始写。

redo log也是写入磁盘中，为什么会快?

因为redo log是直接根据指针的位置继续向下写就可以了，不需要查找成本。

而更新操作需要在磁盘中进行多次I/O操作来查找数据然后再进行修改，因为磁盘的I/O操作比较耗时，所以查找成本比较大。



### 什么是undo log?有什么用？
undo log,也称为回滚日志，是MySQL数据库中InnoDB存储引擎特有的机制。

在数据库中，undo log主要有两个作用：

1. 第一个作用呢，就是提供了事务的回滚功能。当一个事务出现异常需要回滚时，InnoDB可以通过undo log把数据恢复到事务开始之前的状态。
2. 第二个作用是为实现MVCC，也就是多版本并发控制提供了一种机制。在可重复读隔离级别下，为了在事务开始时能读取到一个一致性的快照，需要通过undo log来获取数据在某个时间点的版本。

undo log的存储形式是逻辑日志，记录的是数据被修改的逻辑情况，比如“某行数据的某列从A修改为B”。

补充：

获取数据在某个时间点的版本时的相关细节：

1. 每个事务会按照开始时间，分配一个单调递增的事务编号 trx id
2. 每次事务的改动都会以行为单位记入回滚日志，包括当时的事务编号，改动的值等
3. 查询操作，事务编号大于自己的数据是不可见的，事务编号小于等于自己的数据才是可见的