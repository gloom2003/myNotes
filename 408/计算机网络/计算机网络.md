# 计算机网络

## 其他内容

### 内网穿透原理：

内网的主机安装内网穿透的软件后，与内网穿透的服务器建立连接，服务器提供一个域名并且映射到内网的私有ip与端口，于是，通过访问内网穿透服务器就可以**实现从外到内的网络访问**，不需要公网ip，只需要把内部网络进行穿透，如图：

![https://image.itbaima.net/images/173/image-20231021216093930.png](https://image.itbaima.net/images/173/image-20231021216093930.png)

从内到外的访问：NAT地址转换协议(实现一个私有ip转换为一个公网ip，一对一地址转换)、NAPT协议(根据端口实现多对一的地址转换)

使用frp进行：

我们可以让家里的机器主动连接到云服务器，再由云服务器向我们家里的机器进行数据包转发，实现内网穿透的效果。

### 内网穿透实战,基于fps:

在内网的电脑上安装frp客户端，在服务器上安装frp服务端,以此实现内网穿透。

![https://image.itbaima.net/images/173/image-20231022203103460.png](https://image.itbaima.net/images/173/image-20231022203103460.png)



显而易见，内网穿透就是依靠转发的形式实现的，这样就可以让家里的设备实现外网访问了！

内网穿透优点：

- 省钱，计算资源、存储资源可以全部自行部署
- 安全，内网环境下只要限制好端口，黑客很难入侵
- 宽带大，家用宽带一般是10M上行速度起步（一般为下行速度的十分之一，百兆宽带一般指的是下行速度），办理千兆宽带甚至可以达到100M的上行速度，相比腾讯云的3M小宽带，直接真香，我们可以增加内网穿透服务器的数量并进行**负载均衡**来做到吃满上行带宽。

内网穿透缺点：

- 不稳定，停电、断网、电费等，都是我们需要考虑的因素
- 网络性能瓶颈，网络速度多快，以及能承受的QPS(Queries Per Second意思是“**每秒查询率**”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 )，全部受限于做内网穿透的云服务器上限。

#### 服务端部署frps服务

在GitHub上下载对应的frp程序，解压，然后上传frps到云服务器，执行：

```sh
chmod +x frps
./frps
```

这样就可以直接运行了：

接着我们来编写一下配置文件：

```sh
vim frps.toml
```

内容如下：

```properties
bindPort = 7000    #端口
auth.method = "token"   #验证方式
auth.token = "123456"   #token秘钥
```

以配置文件的方式运行，但是会卡在运行界面，想要后台运行，需要将其配置为Linux服务的形式：

~~~sh
./frps -c frps.toml
~~~



然后我们接着将其配置为Linux服务的形式运行：

文档：https://gofrp.org/zh-cn/

```sh
sudo vim /etc/systemd/system/frps.service
```

配置文件如下：

```properties
[Unit]
Description = frp server
After = network.target syslog.target
Wants = network.target

[Service]
Type = simple
ExecStart = /root/frps -c /root/frps.toml

[Install]
WantedBy = multi-user.target
```

然后我们就可以启动这个服务了：

```sh
systemctl enable frps
systemctl start frps
```

还有别忘了开防火墙端口，包括用于注册的7000端口以及后续给内网其他服务进行穿透的端口（如Nginx的80端口）

#### 在Ubuntu客户端上部署frpc服务

跟服务端一样，直接上传frpc客户端：

```sh
chmod +x frpc
./frpc
```

只不过需要先进行配置才能运行：

![image-20231019175038881](https://s2.loli.net/2023/10/19/MOAoDteFLchb2Hv.png)



接着我们来编写一下配置文件：

```sh
vim frpc.toml
```

内容如下：

```sh
serverAddr = "47.109.97.136"   //之前搭建好的内网穿透服务器地址
serverPort = 7000      //内网穿透服务器注册端口
auth.method = "token"  //使用token验证
auth.token = "123456"  //使用密码

[[proxies]]
name = "nginx"   //配置需要代理的本地服务名称，随便取
type = "tcp"     //类型选择tcp即可（大部分都是，因为http协议是基于tcp的）
localIP = "127.0.0.1"   //本地服务的IP地址，因为是直接部署在本地，所以说直接127.0.0.1，如果是部署中docker中，需要填写docker容器的ip地址
localPort = 80    //本地服务端口
remotePort = 80    //远程代理端口  外部访问remotePort端口时就会全部转发到localPort端口，响应也一样
```

配置完成后，就可以启动拉：

```sh
./frpc -c frpc.toml
```

![image-20231019180806628](https://s2.loli.net/2023/10/19/OhqUKHCSd5l4yBj.png)



为了方便，我们可以直接注册为服务：

```sh
sudo vim /etc/systemd/system/frpc.service
```

内容如下：

```sh
[Unit]
Description = frp client
After = network.target syslog.target
Wants = network.target

[Service]
Type = simple
ExecStart = /root/frpc -c /root/frpc.toml

[Install]
WantedBy = multi-user.target
```

然后我们就可以启动这个服务了：

```sh
systemctl enable frpc
systemctl start frpc
```

然后就可以试试看访问啦~

#### 开启管理面板

服务端开启管理面板，可以更加有效的监控流量情况：

![image-20231019181459596](https://s2.loli.net/2023/10/19/Zob8niGWe6Rfvum.png)



在服务端配置文件中添加以下内容：

```sh
webServer.port = 7500   #管理面板端口
webServer.addr = "0.0.0.0"   #绑定到所有网络上，即：允许所有的ip进行外网访问
webServer.user = "admin"  #管理员名称
webServer.password = "admin"  #管理员密码
```

然后就可以快乐的管理了~

## 趣谈网络协议的内容：

## 1.1 协议的三要素(语法、语义、顺序)

- **语法**，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。
- **语义**，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。
- **顺序**，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。

当你想要买一个商品，常规的做法就是打开浏览器，输入购物网站的地址。浏览器就会给你显示一个缤纷多彩的页面。

那你有没有深入思考过，浏览器是如何做到这件事情的？它之所以能够显示缤纷多彩的页面，是因为它收到了一段来自HTTP协议的“东西”。我拿网易考拉来举例，格式就像下面这样：

```xml
HTTP/1.1 200 OK
Date: Tue, 27 Mar 2018 16:50:26 GMT
Content-Type: text/html;charset=UTF-8
Content-Language: zh-CN

<!DOCTYPE html>
<html>
<head>
<base href="https://pages.kaola.com/" />
<meta charset="utf-8"/> <title>网易考拉3周年主会场</title>
```

这符合协议的三要素吗？我带你来看一下。

首先，符合语法，也就是说，只有按照上面那个格式来，浏览器才认。例如，上来是**状态**，然后是**首部**，然后是**内容**。

第二，符合语义，就是要按照约定的意思来。例如，状态200，表述的意思是网页成功返回。如果不成功，就是我们常见的“404”。

第三，符合顺序，你一点浏览器，就是发送出一个HTTP请求，然后才有上面那一串HTTP返回的东西。

## 1.2 网络通信的过程

你先在浏览器里面输入 [https://www.kaola.com](https://www.kaola.com/) ，这是一个**URL**。浏览器只知道名字是“www.kaola.com”，但是不知道具体的地点，所以不知道应该如何访问。于是，它打开地址簿去查找。可以使用一般的地址簿协议**DNS**去查找，还可以使用另一种更加精准的地址簿查找协议**HTTPDNS**。

无论用哪一种方法查找，最终都会得到这个地址：106.114.138.24。这个是**IP**地址，是互联网世界的“门牌号”。

知道了目标地址，浏览器就开始打包它的请求。对于普通的浏览请求，往往会使用**HTTP**协议；但是对于购物的请求，往往需要进行加密传输，因而会使用**HTTPS**协议。无论是什么协议，里面都会写明“你要买什么和买多少”。﻿

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/d8a65ca347ad26acc9f1de49b10320c6.png)

DNS、HTTP、HTTPS所在的层我们称为**应用层**。经过应用层封装后，浏览器会将应用层的包交给下一层去完成，通过socket编程来实现。下一层是**传输层**。传输层有两种协议，一种是无连接的协议**UDP**，一种是面向连接的协议**TCP**。对于支付来讲，往往使用TCP协议。所谓的面向连接就是，TCP会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。

TCP协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/53c753a7d49c9dfe3cfeb26497e47eee.png)

传输层封装完毕后，浏览器会将包交给操作系统的**网络层**。网络层的协议是**IP协议**。在IP协议里面会有源IP地址，即浏览器所在机器的IP地址和目标IP地址，也即电商网站所在服务器的IP地址。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/459a421975b27f6187d2aa4673171f1b.png)

操作系统既然知道了目标IP地址，就开始想如何根据这个门牌号找到目标机器。操作系统往往会判断，这个目标IP地址是本地人，还是外地人。如果是本地人，从门牌号就能看出来，但是显然电商网站不在本地，而在遥远的地方。

操作系统知道要离开本地去远方。虽然不知道远方在何处，但是可以这样类比一下：如果去国外要去海关，去外地就要去**网关**。而操作系统启动的时候，就会被**DHCP协议**配置IP地址，以及默认的网关的IP地址192.168.1.1。

操作系统如何将IP地址发给网关呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是192.168.1.1啊？网关会回答它，我就是，我的本地地址在村东头。这个本地地址就是**MAC**地址，而大吼的那一声是**ARP**协议。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/cc02190ac57af7fb6c3839534f2b674f.png)

于是操作系统将IP包交给了下一层，也就是**MAC层**。网卡再将包发出去。由于这个包里面是有MAC地址的，因而它能够到达网关。

网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，到某个IP地址应该怎么走，这个叫作路由表。

路由器有点像玄奘西行路过的一个个国家的一个个城关。每个城关都连着两个国家，每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址MAC进行通信。

一旦跨越城关，就需要拿出IP头来，里面写着贫僧来自东土大唐（就是源IP地址），欲往西天拜佛求经（指的是目标IP地址）。路过宝地，借宿一晚，明日启行，请问接下来该怎么走啊？﻿

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/f7ea602aec91c67b35e710fb72a975e2.png)

城关往往是知道这些“知识”的，因为城关和临近的城关也会经常沟通。到哪里应该怎么走，这种沟通的协议称为**路由协议**，常用的有**OSPF**和**BGP**。﻿

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/b25ad7afba7b79331d95875dd0f451d4.png)

城关与城关之间是一个国家，当网络包知道了下一步去哪个城关，还是要使用国家内部的MAC地址，通过下一个城关的MAC地址，找到下一个城关，然后再问下一步的路怎么走，一直到走出最后一个城关。

最后一个城关知道这个网络包要去的地方。于是，对着这个国家吼一声，谁是目标IP啊？目标服务器就会回复一个MAC地址。网络包过关后，通过这个MAC地址就能找到目标服务器。

目标服务器发现MAC地址对上了，取下MAC头来，发送给操作系统的网络层。发现IP也对上了，就取下IP头。IP头里会写上一层封装的是TCP协议，然后将其交给传输层，即**TCP层**。

在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是TCP层的一个说明，即收到之后的回复。当然这个回复，会沿着刚才来的方向走回去，报个平安。

因为一旦出了国门，西行路上千难万险，如果在这个过程中，网络包走丢了，例如进了大沙漠，或者被强盗抢劫杀害怎么办呢？因而到了要报个平安。

如果过一段时间还是没到，发送端的TCP层会重新发送这个包，还是上面的过程，直到有一天收到平安到达的回复。**这个重试绝非你的浏览器重新将下单这个动作重新请求一次**。对于浏览器来讲，就发送了一次下单请求，TCP层不断自己闷头重试。除非TCP这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。

当网络包平安到达TCP层之后，TCP头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个Tomcat，将这个包发给电商网站。﻿

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/b465ccfafe333bfdfb9daf78f96e123f.png)

电商网站的进程得到HTTP请求的内容，知道了要买东西，买多少。往往一个电商网站最初接待请求的这个Tomcat只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。例如，这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉支付的进程，应该付多少钱，等等。

如何告诉相关的进程呢？往往通过**RPC调用**，即远程过程调用的方式来实现。远程过程调用就是当告诉管理订单进程的时候，接待员不用关心中间的网络互连问题，会由RPC框架统一处理。RPC框架有很多种，有基于HTTP协议放在HTTP的报文里面的，有直接封装在TCP报文里面的。

当接待员发现相应的部门都处理完毕，就回复一个HTTPS的包，告知下单成功。这个HTTPS的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功。

## 1.3 ip addr命令的结果解析：

怎么查看IP地址

Windows上是ipconfig，在Linux上是ifconfig。

那你知道在Linux上还有什么其他命令可以查看IP地址吗？答案是ip addr。

```sql
root@test:~# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::f816:3eff:fec7:7975/64 scope link 
       valid_lft forever preferred_lft forever
```



### 1.3.1 ip地址的分类 A-E

本来32位的IP地址就不够，还被分成了5类。现在想想，当时分配地址的时候，真是太奢侈了。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/0b32d6e35ff0bbc5d46cfb87f6669d9e.jpg)

在网络地址中，至少在当时设计的时候，对于A、B、 C类主要分两部分，前面一部分是网络号，后面一部分是主机号。这很好理解，大家都是六单元1001号，我是小区A的六单元1001号，而你是小区B的六单元1001号。

下面这个表格，详细地展示了A、B、C三类地址所能包含的主机的数量。在后文中，我也会多次借助这个表格来讲解。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/e9c59a4b2f0b804356759b10440ea7be.jpg)

这里面有个尴尬的事情，就是C类地址能包含的最大主机数量实在太少了，只有254个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧。而B类地址能包含的最大主机数量又太多了。6万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。

### 1.3.2 无类型域间选路（CIDR）10.100.122.2/24

于是有了一个折中的方式叫作**无类型域间选路**，简称**CIDR**。这种方式打破了原来设计的几类地址的做法，将32位的IP地址一分为二，前面是**网络号**，后面是**主机号**。从哪里分呢？你如果注意观察的话可以看到，10.100.122.2/24，这个IP地址中有一个斜杠，斜杠后面有个数字24。这种地址表示形式，就是CIDR。后面24的意思是，32位中，前24位是网络号，后8位是主机号。

伴随着CIDR存在的，一个是**广播地址**，10.100.122.255。如果发送这个地址，所有10.100.122网络里面的机器都可以收到。另一个是**子网掩码**，255.255.255.0。

将子网掩码和IP地址进行AND计算。前面三个255，转成二进制都是1。1和任何数值取AND，都是原来数值，因而前三个数不变，为10.100.122。后面一个0，转换成二进制是0，0和任何数值取AND，都是0，因而最后一个数变为0，合起来就是10.100.122.0。这就是**网络号**。**将子网掩码和IP地址按位计算AND，就可得到网络号。**



### 1.3.3 公有IP地址和私有IP地址

在日常的工作中，几乎不用划分A类、B类或者C类，所以时间长了，很多人就忘记了这个分类，而只记得CIDR。但是有一点还是要注意的，就是公有IP地址和私有IP地址。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/901778433f2d6e27b916e9e53c232d93.jpg)

我们继续看上面的表格。表格最右列是私有IP地址段。平时我们看到的数据中心里，办公室、家里或学校的IP地址，一般都是私有IP地址段。因为这些地址允许组织内部的IT人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有IP地址段和我学校的可以是一样的。

这就像每个小区有自己的楼编号和门牌号，你们小区可以叫6栋，我们小区也叫6栋，没有任何问题。但是一旦出了小区，就需要使用公有IP地址。就像人民路888号，是国家统一分配的，不能两个小区都叫人民路888号。

公有IP地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的IT人员给你一个IP地址就行。但是假如你要做一个类似网易163这样的网站，就需要有公有IP地址，这样全世界的人才能访问。

**表格中的192.168.0.x是最常用的私有IP地址。你家里有Wi-Fi，对应就会有一个IP地址。一般你家里地上网设备不会超过256个，所以/24基本就够了。有时候我们也能见到/16的CIDR，这两种是最常见的，也是最容易理解的。**

不需要将十进制转换为二进制32位，就能明显看出192.168.0是网络号，后面是主机号。而整个网络里面的第一个地址192.168.0.1，往往就是你这个私有网络的出口地址。例如，你家里的电脑连接Wi-Fi，Wi-Fi路由器的地址就是192.168.0.1，而192.168.0.255就是广播地址。一旦发送这个地址，整个192.168.0网络里面的所有机器都能收到。

但是也不总都是这样的情况。因此，其他情况往往就会很难理解，还容易出错。

### 1.3.4 举例：一个容易“犯错”的CIDR

我们来看16.158.165.91/22这个CIDR。求一下这个网络的第一个地址、子网掩码和广播地址。

你要是上来就写16.158.165.1，那就大错特错了。

/22不是8的整数倍，不好办，只能先变成二进制来看。16.158的部分不会动，它占了前16位。中间的165，变为二进制为‭10100101‬。除了前面的16位，还剩6位。所以，这8位中前6位是网络号，16.158.<101001>，而<01>.91是机器号。

第一个地址是16.158.<101001><00>.1，即16.158.164.1。子网掩码是255.255.<111111><00>.0，即255.255.252.0。广播地址为16.158.<101001><11>.255，即16.158.167.255。

这五类地址中，还有一类D类是**组播地址**。使用这一类地址，属于某个组的机器都能收到。这有点类似在公司里面大家都加入了一个邮件组。发送邮件，加入这个组的都能收到。组播地址在后面讲述VXLAN协议的时候会提到。

讲了这么多，才讲了上面的输出结果中很小的一部分，是不是觉得原来并没有真的理解ip addr呢？我们接着来分析。

在IP地址的后面有个scope，对于eth0这张网卡来讲，是global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于lo来讲，是host，说明这张网卡仅仅可以供本机相互通信。

lo全称是**loopback**，又称**环回接口**，往往会被分配到127.0.0.1这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。

### 1.3.5 MAC地址

在IP地址的上一行是link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为**MAC地址**，是一个网卡的物理地址，用十六进制，6个byte表示。

MAC地址是一个很容易让人“误解”的地址。因为MAC地址号称全局唯一，不会有两个网卡有相同的MAC地址，而且网卡自生产出来，就带着这个地址。很多人看到这里就会想，既然这样，整个互联网的通信，全部用MAC地址好了，只要知道了对方的MAC地址，就可以把信息传过去。

这样当然是不行的。 **一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能。** 而有门牌号码属性的IP地址，才是有远程定位功能的。

例如，你去杭州市网商路599号B楼6层找刘超，你在路上问路，可能被问的人不知道B楼是哪个，但是可以给你指网商路怎么去。但是如果你问一个人，你知道这个身份证号的人在哪里吗？可想而知，没有人知道。

MAC地址更像是身份证，是一个唯一的标识。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。

MAC地址是有一定定位功能的，只不过范围非常有限。你可以根据IP地址，找到杭州市网商路599号B楼6层，但是依然找不到我，你就可以靠吼了，大声喊身份证XXXX的是哪位？我听到了，我就会站起来说，是我啊。但是如果你在上海，到处喊身份证XXXX的是哪位，我不在现场，当然不会回答，因为我在杭州不在上海。

所以，MAC地址的通信范围比较小，局限在一个子网里面。例如，从192.168.0.2/24访问192.168.0.3/24是可以用MAC地址的。一旦跨子网，即从192.168.0.2/24到192.168.1.2/24，MAC地址就不行了，需要IP地址起作用了。

### 1.3.6 网络设备的状态标识

解析完了MAC地址，我们再来看 是干什么的？这个叫作**net_device flags**，**网络设备的状态标识**。

UP表示网卡处于启动的状态；BROADCAST表示这个网卡有广播地址，可以发送广播包；MULTICAST表示网卡可以发送多播包；LOWER_UP表示L1是启动的，也即网线插着呢。MTU1500是指什么意思呢？是哪一层的概念呢？最大传输单元MTU为1500，这是以太网的默认值。

上一节，我们讲过网络包是层层封装的。**MTU是二层MAC层的概念**。MAC层有MAC的头，以太网规定连MAC头带正文合起来，不允许超过1500个字节。正文里面有IP的头、TCP的头、HTTP的头。如果放不下，就需要分片来传输。

qdisc pfifo_fast是什么意思呢？qdisc全称是**queueing discipline**，中文叫**排队规则**。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的qdisc（排队规则）把数据包加入队列。

最简单的qdisc是pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。

三个波段（band）的优先级也不相同。band 0的优先级最高，band 2的最低。如果band 0里面有数据包，系统就不会处理band 1里面的数据包，band 1和band 2之间也是一样。

数据包是按照服务类型（**Type of Service，TOS**）被分配到三个波段（band）里面的。TOS是IP头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。

队列是个好东西，后面我们讲云计算中的网络的时候，会有很多用户共享一个网络出口的情况，这个时候如何排队，每个队列有多粗，队列处理速度应该怎么提升，我都会详细为你讲解。

### 1.3.7 小结

怎么样，看起来很简单的一个命令，里面学问很大吧？通过这一节，希望你能记住以下的知识点，后面都能用得上：

- IP是地址，有定位功能；MAC是身份证，无定位功能；
- CIDR可以用来判断是不是本地人；
- IP分公有的IP和私有的IP。后面的章节中我会谈到“出国门”，就与这个有关。

## 2 常见协议

### 2.1 ARP协议

根据ip地址获取MAC地址,只有是同一个网段的，它才会发送ARP请求，获取MAC地址。例如：发送数据到同一个网段的网关，则会根据网关的ip地址获取MAC地址，然后写入到mac头中，从而能够发送定位到网关，成功发送数据。

### 2.2 动态主机配置协议（DHCP）

原来配置IP有这么多门道儿啊。你可能会问了，配置了IP之后一般不能变的，配置一个服务端的机器还可以，但是如果是客户端的机器呢？我抱着一台笔记本电脑在公司里走来走去，或者白天来晚上走，每次使用都要配置IP地址，那可怎么办？还有人事、行政等非技术人员，如果公司所有的电脑都需要IT人员配置，肯定忙不过来啊。

因此，我们需要有一个自动配置的协议，也就是称**动态主机配置协议（Dynamic Host Configuration Protocol）**，简称**DHCP**。

有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的IP地址。每一台新接入的机器都通过DHCP协议，来这个共享的IP地址里申请，然后自动配置好就可以了。等人走了，或者用完了，还回去，这样其他的机器也能用。

所以说，**如果是数据中心里面的服务器，IP一旦配置好，基本不会变，这就相当于买房自己装修。DHCP的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。**

#### 2.2.1  解析DHCP的工作方式

当一台机器新加入一个网络的时候，肯定一脸懵，啥情况都不知道，只知道自己的MAC地址。怎么办？先吼一句，我来啦，有人吗？这时候的沟通基本靠“吼”。这一步，我们称为**DHCP Discover。**

新来的机器使用IP地址0.0.0.0发送了一个广播包，目的IP地址为255.255.255.255。广播包封装了UDP，UDP封装了BOOTP。其实DHCP是BOOTP的增强版，但是如果你去抓包的话，很可能看到的名称还是BOOTP协议。

在这个广播包里面，新人大声喊：我是新来的（Boot request），我的MAC地址是这个，我还没有IP，谁能给租给我个IP地址！

格式就像这样：

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/395b304f49559034af34c882bd86f11f.jpg)

如果一个网络管理员在网络里面配置了**DHCP Server**的话，他就相当于这些IP的管理员。他立刻能知道来了一个“新人”。这个时候，我们可以体会MAC地址唯一的重要性了。当一台机器带着自己的MAC地址加入一个网络的时候，MAC是它唯一的身份，如果连这个都重复了，就没办法配置了。

只有MAC唯一，IP管理员才能知道这是一个新人，需要租给它一个IP地址，这个过程我们称为**DHCP Offer**。同时，DHCP Server为此客户保留为它提供的IP地址，从而不会为其他DHCP客户分配此IP地址。

DHCP Offer的格式就像这样，里面有给新人分配的地址。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/54ffefbe4f493f0f4a39f45504bd5086.jpg)

DHCP Server仍然使用广播地址作为目的地址，因为，此时请求分配IP的新人还没有自己的IP。DHCP Server回复说，我分配了一个可用的IP给你，你看如何？除此之外，服务器还发送了子网掩码、网关和IP地址租用期等信息。

新来的机器很开心，它的“吼”得到了回复，并且有人愿意租给它一个IP地址了，这意味着它可以在网络上立足了。当然更令人开心的是，如果有多个DHCP Server，这台新机器会收到多个IP地址，简直受宠若惊。

它会选择其中一个DHCP Offer，一般是最先到达的那个，并且会向网络发送一个DHCP Request广播数据包，包中包含客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器地址等，并告诉所有DHCP Server它将接受哪一台服务器提供的IP地址，告诉其他DHCP服务器，谢谢你们的接纳，并请求撤销它们提供的IP地址，以便提供给下一个IP租用请求者。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/e1e45ba0d86d2774ec80a1d86f87b724.jpg)

此时，由于还没有得到DHCP Server的最后确认，客户端仍然使用0.0.0.0为源IP地址、255.255.255.255为目标地址进行广播。在BOOTP里面，接受某个DHCP Server的分配的IP。

当DHCP Server接收到客户机的DHCP request之后，会广播返回给客户机一个DHCP ACK消息包，表明已经接受客户机的选择，并将这一IP地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/7da571c18b974582a9cfe4718c5dea0e.jpg)

最终租约达成的时候，还是需要广播一下，让大家都知道。

#### 2.2.2 IP地址的收回和续租

既然是租房子，就是有租期的。租期到了，管理员就要将IP收回。

如果不用的话，收回就收回了。就像你租房子一样，如果还要续租的话，不能到了时间再续租，而是要提前一段时间给房东说。DHCP也是这样。

客户机会在租期过去50%的时候，直接向为其提供IP地址的DHCP Server发送DHCP request消息包。客户机接收到该服务器回应的DHCP ACK消息包，会根据包中所提供的新的租期以及其他已经更新的TCP/IP参数，更新自己的配置。这样，IP租用更新就完成了。

### 2.3 PXE协议

#### 2.3.1 预启动执行环境（PXE）

普通的笔记本电脑，一般不会有这种需求。因为你拿到电脑时，就已经有操作系统了，即便你自己重装操作系统，也不是很麻烦的事情。但是，在数据中心里就不一样了。数据中心里面的管理员可能一下子就拿到几百台空的机器，一个个安装操作系统，会累死的。

所以管理员希望的不仅仅是自动分配IP地址，还要自动安装系统。装好系统之后自动分配IP地址，直接启动就能用了，这样当然最好了！

这事儿其实仔细一想，还是挺有难度的。安装操作系统，应该有个光盘吧。数据中心里不能用光盘吧，想了一个办法就是，可以将光盘里面要安装的操作系统放在一个服务器上，让客户端去下载。但是客户端放在哪里呢？它怎么知道去哪个服务器上下载呢？客户端总得安装在一个操作系统上呀，可是这个客户端本来就是用来安装操作系统的呀？

其实，这个过程和操作系统启动的过程有点儿像。首先，启动BIOS。这是一个特别小的小系统，只能干特别小的一件事情。其实就是读取硬盘的MBR启动扇区，将GRUB启动起来；然后将权力交给GRUB，GRUB加载内核、加载作为根文件系统的initramfs文件；然后将权力交给内核；最后内核启动，初始化整个操作系统。

那我们安装操作系统的过程，只能插在BIOS启动之后了。因为没安装系统之前，连启动扇区都没有。因而这个过程叫做**预启动执行环境（Pre-boot Execution Environment）**，简称**PXE。**

**PXE协议**分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在BIOS里面。当计算机启动时，BIOS把PXE客户端调入内存里面，就可以连接到服务端做一些操作了。

首先，PXE客户端自己也需要有个IP地址。因为PXE的客户端启动起来，就可以发送一个DHCP的请求，让DHCP Server给它分配一个地址。PXE客户端有了自己的地址，那它怎么知道PXE服务器在哪里呢？对于其他的协议，都好办，要么人告诉他。例如，告诉浏览器要访问的IP地址，或者在配置中告诉它；例如，微服务之间的相互调用。

但是PXE客户端启动的时候，啥都没有。好在DHCP Server除了分配IP地址以外，还可以做一些其他的事情。这里有一个DHCP Server的一个样例配置：

```lua
ddns-update-style interim;
ignore client-updates;
allow booting;
allow bootp;
subnet 192.168.1.0 netmask 255.255.255.0
{
option routers 192.168.1.1;
option subnet-mask 255.255.255.0;
option time-offset -18000;
default-lease-time 21600;
max-lease-time 43200;
range dynamic-bootp 192.168.1.240 192.168.1.250;
filename "pxelinux.0";
next-server 192.168.1.180;
}
```

按照上面的原理，默认的DHCP Server是需要配置的，无非是我们配置IP的时候所需要的IP地址段、子网掩码、网关地址、租期等。如果想使用PXE，则需要配置next-server，指向PXE服务器的地址，另外要配置初始启动文件filename。

这样PXE客户端启动之后，发送DHCP请求之后，除了能得到一个IP地址，还可以知道PXE服务器在哪里，也可以知道如何从PXE服务器上下载某个文件，去初始化操作系统。

#### 2.3.2  解析PXE的工作过程

接下来我们来详细看一下PXE的工作过程。

首先，启动PXE客户端。第一步是通过DHCP协议告诉DHCP Server，我刚来，一穷二白，啥都没有。DHCP Server便租给它一个IP地址，同时也给它PXE服务器的地址、启动文件pxelinux.0。

其次，PXE客户端知道要去PXE服务器下载这个文件后，就可以初始化机器。于是便开始下载，下载的时候使用的是**TFTP协议**。所以PXE服务器上，往往还需要有一个TFTP服务器。PXE客户端向TFTP服务器请求下载这个文件，TFTP服务器说好啊，于是就将这个文件传给它。

然后，PXE客户端收到这个文件后，就开始执行这个文件。这个文件会指示PXE客户端，向TFTP服务器请求计算机的配置信息pxelinux.cfg。TFTP服务器会给PXE客户端一个配置文件，里面会说内核在哪里、initramfs在哪里。PXE客户端会请求这些文件。

最后，启动Linux内核。一旦启动了操作系统，以后就啥都好办了。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/6e69007db3fc68ff6da8496266abf6a4.jpg)

#### 2.3.3 小结

好了，这一节就到这里了。我来总结一下今天的内容：

- DHCP协议主要是用来给客户租用IP地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单”；
- DHCP协议能给客户推荐“装修队”PXE，能够安装操作系统，这个在云计算领域大有用处。

最后，学完了这一节，给你留两个思考题吧。

1. PXE协议可以用来安装操作系统，但是如果每次重启都安装操作系统，就会很麻烦。你知道如何使得第一次安装操作系统，后面就正常启动吗？
2. 现在上网很简单了，买个家用路由器，连上WIFI，给DHCP分配一个IP地址，就可以上网了。那你是否用过更原始的方法自己组过简单的网呢？说来听听。





##  3 交换机、STP协议、VLAN
1.当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用STP协议(复杂)，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。
2.交换机数目多会面临广播问题和安全问题,可以通过VLAN形成虚拟局域网，从而解决广播问题和安全问题。

### 如何解决广播问题和安全问题？
1.物理隔离:
每个部门设一个单独的会议室，对应到网络方面，就是每个部门有单独的交换机，配置单独的子网，这样部门之间的沟通就需要路由器了。路由器咱们还没讲到，以后再说。这样的问题在于，有的部门人多，有的部门人少。人少的部门慢慢人会变多，人多的部门也可能人越变越少。如果每个部门有单独的交换机，口多了浪费，少了又不够用。

2.虚拟隔离:就是用我们常说的VLAN，或者叫虚拟局域网。使用VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？只需要在原来的二层的头上加一个TAG，里面有一个VLAN ID，一共12位，可划分4096个VLAN ID。如果我们买的交换机是支持VLAN的，当这个交换机把二层的头取下来的时候，就能够识别这个VLAN ID。这样只有相同VLAN的包，才会互相转发，不同VLAN的包，是看不到的。这样广播问题和安全问题就都能够解决了。
       而且对于交换机来讲，每个VLAN的口都是可以重新设置的。将两个交换机连接起来的口应该设置成什么VLAN呢？对于支持VLAN的交换机，有一种口叫作Trunk口。它可以转发属于任何VLAN的口。交换机之间可以通过这种口相互连接。

## 4 ping命令解析:

ping是基于ICMP协议工作的。ICMP报文是封装在IP包里面的。因为传输指令的时候，肯定需要源地址和目标地址。ICMP报文有很多的类型，不同的类型有不同的代码。最常用的类型是主动请求为8，主动请求的应答为0。
查询报文类型
我们经常在电视剧里听到这样的话：主帅说，来人哪！前方战事如何，快去派人打探，一有情况，立即通报！

这种是主帅发起的，主动查看敌情，对应ICMP的查询报文类型。例如，常用的ping就是查询报文，是一种主动请求，并且获得主动应答的ICMP协议。所以，ping发的包也是符合ICMP协议格式的，只不过它在后面增加了自己的格式。

对ping的主动请求，进行网络抓包，称为ICMP ECHO REQUEST。同理主动请求的回复，称为ICMP ECHO REPLY。比起原生的ICMP，这里面多了两个字段，一个是标识符。这个很好理解，你派出去两队侦查兵，一队是侦查战况的，一队是去查找水源的，要有个标识才能区分。另一个是序号，你派出去的侦查兵，都要编个号。如果派出去10个，回来10个，就说明前方战况不错；如果派出去10个，回来2个，说明情况可能不妙。
         在选项数据中，ping还会存放发送请求的时间值，来计算往返时间，说明路程的长短。

### 差错报文类型

当然也有另外一种方式，就是差错报文。

主帅骑马走着走着，突然来了一匹快马，上面的小兵气喘吁吁的：报告主公，不好啦！张将军遭遇埋伏，全军覆没啦！这种是异常情况发起的，来报告发生了不好的事情，对应ICMP的差错报文类型。

我举几个ICMP差错报文的例子：终点不可达为3，源抑制为4，超时为11，重定向为5。这些都是什么意思呢？我给你具体解释一下。

第一种是终点不可达。小兵：报告主公，您让把粮草送到张将军那里，结果没有送到。

如果你是主公，你肯定会问，为啥送不到？具体的原因在代码中表示就是，网络不可达代码为0，主机不可达代码为1，协议不可达代码为2，端口不可达代码为3，需要进行分片但设置了不分片位代码为4。

具体的场景就像这样：

网络不可达：主公，找不到地方呀？

主机不可达：主公，找到地方没这个人呀？

协议不可达：主公，找到地方，找到人，口号没对上，人家天王盖地虎，我说12345！

端口不可达：主公，找到地方，找到人，对了口号，事儿没对上，我去送粮草，人家说他们在等救兵。

需要进行分片但设置了不分片位：主公，走到一半，山路狭窄，想换小车，但是您的将令，严禁换小车，就没办法送到了。

第二种是源站抑制，也就是让源站放慢发送速度。小兵：报告主公，您粮草送的太多了吃不完。

第三种是时间超时，也就是超过网络包的生存时间还是没到。小兵：报告主公，送粮草的人，自己把粮草吃完了，还没找到地方，已经饿死啦。

第四种是路由重定向，也就是让下次发给另一个路由器。小兵：报告主公，上次送粮草的人本来只要走一站地铁，非得从五环绕，下次别这样了啊。

差错报文的结构相对复杂一些。除了前面还是IP，ICMP的前8字节不变，后面则跟上出错的那个IP包的IP头和IP正文的前8个字节。

而且这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来。

侦察兵：报告主公，张将军已经战死沙场，这是张将军的印信和佩剑。

主公：神马？张将军是怎么死的（可以查看ICMP的前8字节）？没错，这是张将军的剑，是他的剑（IP数据包的头及正文前8字节）。

ping命令执行的时候，源主机首先会构建一个ICMP请求数据包，ICMP数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 8；另外一个是顺序号，主要用于区分连续ping的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加1。为了能够计算往返时间RTT，它会在报文的数据部分插入发送时间。
然后，由ICMP协议将这个数据包连同地址192.168.1.2一起交给IP层。

目的主机B收到后，待IP层检查后，将有用的信息提取后交给ICMP协议。

主机B会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机A。

在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。

如果不在我们的控制范围内，很多中间设备都是禁止ping的，但是ping不通不代表网络不通。这个时候就要使用telnet，通过其他协议来测试网络是否通

ICMP报文通常封装在IP数据报中，因此它在网络层运作。 ICMP的主要作用是在IP网络中传递诸如错误报告、网络可达性和路由信息等消息，而不是在传输层上建立端到端的数据传输连接。传输层的协议，如TCP和UDP，负责实现端到端的数据传输和可靠性，而网络层的协议（如IP和ICMP）则负责路由和网络通信的控制。


   ### Traceroute命令的作用:
有一个程序Traceroute，是个“大骗子”。它会使用ICMP的规则，故意制造一些能够产生错误的场景。

所以，Traceroute的第一个作用就是故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器,获得其中的ip地址，当然，有的路由器压根不会回这个ICMP。这也是Traceroute一个公网的地址，看不到中间路由的原因。
Traceroute还有一个作用是故意设置不分片，从而确定路径的MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口MTU相等。如果中间遇到窄的关口会被卡住，会发送ICMP网络差错包，类型为“需要进行分片但设置了不分片位”。其实，这是人家故意的好吧，每次收到ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机。

  #### 小结:

ICMP相当于网络世界的侦察兵。我讲了两种类型的ICMP报文，一种是主动探查的查询报文，一种异常报告的差错报文；
ping使用查询报文，Traceroute使用差错报文。

## 5 路由器的功能:

服务类型TOS在第三节讲ip addr命令的时候讲过，数据包是按照服务类型（**Type of Service，TOS**）被分配到三个波段（band）里面的。TOS是IP头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。

网关往往是一个路由器，是一个三层转发的设备。啥叫三层设备？前面也说过了，就是把MAC头和IP头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。

在你的宿舍里面，网关就是你宿舍长的电脑。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源IP同网段的。

很多情况下，人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：路由器是一台设备，它有五个网口或者网卡(或网关？)，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。
任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下MAC头和IP头，看看，根据自己的路由算法，选择另一只手，加上IP头和MAC头，然后扔出去。

### 路由器的路由与寻址:

1.静态路由:其实就是在路由器上，配置一条一条规则。这些规则包括：想访问BBS站（它肯定有个网段），从2号口出去，下一跳是IP2；想访问教学视频站（它也有个自己的网段），从3号口出去，下一跳是IP3，然后保存在路由器里。

每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳IPX。
每到一个新的局域网，MAC都是要变的，但是IP地址都不变。在IP头里面，不会保存任何网关的IP地址。所谓的下一跳是，要将这个IP地址通过ARP请求转换为MAC,放入MAC头中作为目标MAC地址。

不改变IP地址的网关，我们称为转发网关；改变IP地址的网关，我们称为NAT网关。

### 小结:
如果离开本局域网，就需要经过网关，网关是路由器的一个网口；

路由器是一个三层设备，里面有如何寻找下一跳的规则；

经过路由器之后MAC头要变，如果IP不变，相当于不换护照的欧洲旅游，如果IP变，相当于换护照的玄奘西行。

### 如何配置路由

#### 静态路由:

当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为路由表。
一张路由表中会有多条路由规则。每一条规则至少包含这三项信息。

1.目的网络：这个包想去哪儿？
2.出口设备：将包从哪个口扔出去？
3.下一跳网关：下一个路由器的地址。
上一节的例子中，网关上的路由策略就是按照这三项配置信息进行配置的。这种配置方式的一个核心思想是：**根据目的IP地址来配置路由。**

当然，在真实的复杂的网络环境中，除了可以根据目的ip地址配置路由外，还可以根据多个参数来配置路由，这就称为**策略路由**。

可以配置多个路由表，可以根据源IP地址、入口设备、TOS等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。

如果总是用静态路由，一旦网络结构发生变化，让网络管理员手工修改路由太复杂了，因而需要动态路由算法。



#### 动态路由算法:

##### 1.距离矢量路由算法

每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到达目标路由器，从哪条线出去，另一个是到目标路由器的距离。

每个路由器都是知道全局信息的。每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。每个路由器根据新收集的信息，计算和其他路由器的距离。

问题：1.好消息传得快，坏消息传得慢(记录距离的数会越来越大，直到超过一个阈值，我们才能判定一个路由器真的挂了。)

2.每次发送的时候，要发送整个全局路由表。网络大了，谁也受不了，所以最早的路由协议RIP就是这个算法。它适用于小型网络（小于15跳）。当网络规模都小的时候，没有问题。现在一个数据中心内部路由器数目就很多，因而不适用了。

所以上面的两个问题，限制了距离矢量路由的网络规模。



###### 基于距离矢量路由算法的BGP(外网的路由协议)

外网路由协议（Border Gateway Protocol，简称BGP）

在网络世界，这一个个区域称为自治系统AS（Autonomous System）。

在一个AS内部，有路当然选近的走。但是AS之间，不光远近的问题，还有政策的问题。

自治系统分几种类型。

- Stub AS：对外只有一个连接。这类AS不会传输其他AS的包。例如，个人或者小公司的网络。

- Multihomed AS：可能有多个连接连到其他的AS，但是大多拒绝帮其他的AS传输包。例如一些大公司的网络。

- Transit AS：有多个连接连到其他的AS，并且可以帮助其他的AS传输包。例如主干网。


每个自治系统都有边界路由器，通过它和外面的世界建立联系。
如图:

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/c3bce0ec298138d8e36e6ebf1375d843.jpg)

BGP又分为两类，eBGP和iBGP。自治系统AS间，边界路由器之间使用eBGP广播路由。内部网络也需要访问其他的自治系统。BGP协议使用的算法是路径矢量路由协议（path-vector protocol）。它是距离矢量路由协议的升级版(解决了坏消息传得慢的问题)。通过运行iBGP，边界路由器将BGP学习到的路由导入到内部网络，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。

前面说了距离矢量路由协议的缺点。其中一个是收敛慢。在BGP里面，除了下一跳hop之外，还包括了自治系统AS的路径，从而可以避免坏消息传的慢的问题，也即上面所描述的，B知道C原来能够到达A，是因为通过自己，一旦自己都到达不了A了，就不用假设C还能到达A了。

在路径中将一个自治系统看成一个整体，不区分自治系统内部的路由器，这样自治系统的数目是非常有限的。就像大家都能记住出去玩，从中国出发先到韩国然后到日本，只要不计算细到具体哪一站，就算是发送全局信息，也是没有问题的。



##### 2.链路状态路由算法(基于Dijkstra算法)

这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居say hello，邻居都回复。然后计算和邻居的距离，发送一个echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用Dijkstra算法，找到两点之间的最短路径。
不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和CPU利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。

###### OSPF协议(内网的路由协议)
OSPF（Open Shortest Path First，开放式最短路径优先）协议，基于链路状态路由协议，由于主要用在数据中心内部，用于路由决策，因而称为内部网关协议（Interior Gateway Protocol，简称IGP）。

内部网关协议IGP的重点就是找到最短的路径。在一个组织内部，路径最短往往最优且可能具有多条最短路径(等价路由)。可以在这多个最短路径中进行负载均衡。

有了等价路由，到一个地方去可以有相同的两个路线，可以分摊流量，还可以当一条路不通的时候，走另外一条路。这个在后面我们讲数据中心的网络的时候，一般应用的接入层会有负载均衡LVS。它可以和OSPF一起，实现高吞吐量的接入层设计。

### 小结:
做个总结：
路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；

动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP协议(外部路由协议)和OSPF协议(内部网关协议)。

## 思考题与GPT回答:
1.路由协议要在路由器之间交换信息，这些信息的交换还需要走路由吗？不是死锁了吗？
路由协议确实需要在路由器之间交换信息，但这些信息通常是通过网络互连的链路传输的，而不是通过路由器自身。
"通过网络互连的链路传输" 意味着路由器之间的通信是通过连接这些路由器的物理或逻辑链路进行的。这些链路可以是物理电缆、光纤、或者逻辑链路（如虚拟专用网络连接）。路由器使用这些链路来交换路由协议信息，以了解网络的拓扑结构和可用路径。

举例来说，如果有两台路由器 A 和 B，它们通过一条物理电缆连接在一起，路由协议信息可以通过这个物理链路传输，以便它们互相了解彼此和相邻网络的状态。这个过程是为了确保路由器在决定如何转发数据包时具有正确的路由表信息。链路传输是路由器之间进行信息交换的基础。


2.路由器之间信息的交换使用什么协议呢？报文格式是什么样呢？

路由器之间的信息交换使用不同的路由协议，具体取决于网络的配置和需求。以下是一些常见的路由协议以及它们的报文格式：

- OSPF (Open Shortest Path First)：OSPF 是一个内部网关协议，它使用Link State Advertisement（LSA）来交换路由信息。 OSPF的报文包括Hello报文、LSA报文和LSU报文。这些报文包含有关网络拓扑和邻居路由器的信息。

- BGP (Border Gateway Protocol)：BGP是一个用于互联网路由的外部网关协议。它使用BGP更新报文来交换路由信息，这些报文包含AS路径、可达性信息等，用于控制路由到不同的IP前缀。

- RIP (Routing Information Protocol)：RIP是一个距离向量协议，它使用RIP消息来交换路由信息。RIP消息包含路由表信息和跳数等。

- EIGRP (Enhanced Interior Gateway Routing Protocol)：EIGRP是思科的专有协议，它使用EIGRP数据包来交换路由信息，包括拓扑表、邻居信息等。

- IS-IS (Intermediate System to Intermediate System)：IS-IS是一种链路状态路由协议，它使用Hello报文和Link State PDUs来交换路由信息。


每个协议的报文格式和交换机制都有细微的差异，以适应不同的网络环境和需求。这些协议的设计旨在确保有效的路由信息传递，以实现网络的正常运行。

## 6 TCP与UDP


### TCP和UDP有哪些区别？
1.TCP是面向连接的，UDP是面向无连接的。
在互通之前，面向连接的协议会先建立连接。所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。

TCP提供可靠交付。通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达。UDP继承了IP包的特性，不保证不丢失，不保证按顺序到达。

2.TCP是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP就不会，应用让我发，我就发，管它洪水滔天。

3.TCP其实是一个有状态服务，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而UDP则是无状态服务。通俗地说是没脑子的，天真无邪的，发出去就发出去了。

### 各层的基础知识
MAC层定义了本地局域网的传输行为，IP层定义了整个网络端到端的传输行为

网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。

### 6.1 UDP

#### UDP包头是什么样的？

在IP头里面有个8位的协议，这里会存放，数据里面到底是TCP格式还是UDP格式，如果是UDP格式，就能够根据UDP头的格式，从数据里面将它解析出来。

如图:

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/6d1313f51b9dfd7ab454b2cef1cb37bf.jpg)

无论应用程序是使用TCP传数据，还是UDP传数据，都要监听一个端口。正是这个端口，用来区分应用程序。无论是TCP还是UDP包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。

#### UDP的三大特点
1.沟通简单，不需要大量的数据结构、处理逻辑、包头字段。
2.它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。
3.它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。

#### UDP的三大使用场景

第一，需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。
我们在第四节讲的DHCP就是基于UDP协议的。一般的获取IP地址都是内网请求，而且一次获取不到IP又没事，过一会儿还有机会。我们讲过PXE可以在启动的时候自动安装操作系统，操作系统镜像的下载使用的TFTP，这个也是基于UDP协议的。在还没有操作系统的时候，客户端拥有的资源很少，不适合维护一个复杂的状态机，而是因为是内网，一般也没啥问题。

第二，不需要一对一沟通，建立连接，而是可以广播的应用。
UDP的不面向连接的功能，可以使得可以承载广播或者多播的协议。DHCP就是一种广播的形式，就是基于UDP协议的，而广播包的格式前面说过了。

对于多播，我们在讲IP地址的时候，讲过一个D类地址，也即组播地址，使用这个地址，可以将包组播给一批机器。当一台机器上的某个进程想监听某个组播地址的时候，需要发送IGMP包，所在网络的路由器就能收到这个包，知道有个机器上有个进程在监听这个组播地址。当路由器收到这个组播地址的时候，会将包转发给这台机器，这样就实现了跨路由器的组播。

在后面云中网络部分，有一个协议VXLAN，也是需要用到组播，也是基于UDP协议的。

第三，需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。

当前很多应用都是要求低时延的，它们可不想用TCP如此复杂的机制，而是想根据自己的场景，实现自己的可靠和连接保证。例如，如果应用自己觉得，有的包丢了就丢了，没必要重传了，就可以算了，有的比较重要，则应用自己重传，而不依赖于TCP。





#### 基于tcp,udp来自定义自己的网络协议
访问网页和手机APP都是基于HTTP协议的。HTTP协议是基于TCP的，建立连接都需要多次交互，建立连接都需要多次交互，对于时延比较大的目前主流的移动互联网来讲，建立一次连接需要的时间会比较长，然而既然是移动中，TCP可能还会断了重连，也是很耗时的。而且目前的HTTP协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是TCP的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。

##### QUIC
而QUIC（全称Quick UDP Internet Connections，快速UDP互联网连接）是Google提出的一种基于UDP改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。
QUIC在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制，是应用层“城会玩”的代表。

UDP虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如DHCP、VXLAN、QUIC等。


实时游戏中客户端和服务端要建立长连接，来保证实时传输。但是游戏玩家很多，服务器却不多。由于维护TCP连接需要在内核维护一些数据结构，因而一台机器能够支撑的TCP连接数目是有限的，然后UDP由于是没有连接的，在异步IO机制引入之前，常常是应对海量客户端连接的策略。

异步I/O是计算机操作系统对输入输出的一种处理方式：发起I/O请求的线程不等I/O操作完成，就继续执行随后的代码，I/O结果用其他方式通知发起I/O请求的程序。 与异步I/O相对的是更为常见的“同步（阻塞）I/O”：发起I/O请求的线程不从正在调用的I/O操作函数返回（即被阻塞），直至I/O操作完成。

游戏对实时要求较为严格的情况下，采用自定义的可靠UDP协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。

#### 思考题:
1.都说TCP是面向连接的，在计算机看来，怎么样才算一个连接呢？

在计算机通信中，一个连接通常是通过以下方式定义的：

\1. IP地址和端口号：一个连接由两台计算机之间的IP地址和端口号组合来标识。通常情况下，一个连接由一个源IP地址和端口号与目标IP地址和端口号相组合而成。这四个值唯一标识了一个连接。

\2. 三次握手：在TCP协议中，建立连接通常需要进行三次握手过程。这包括客户端向服务器发送一个连接请求，服务器回应确认，并最终客户端再次确认。这个过程确保了双方都同意建立连接，从而形成一个连接。

\3. 连接状态：在TCP连接建立后，它会有不同的状态，包括已建立（ESTABLISHED）、已关闭（CLOSED）、等待关闭（FIN-WAIT）等。连接状态的管理也是维护连接的一部分。

\4. 数据交换：一旦连接建立，数据可以在双方之间进行传输。连接的生命周期包括数据的传输、错误处理、流控制等。

总的来说，一个TCP连接可以被定义为一对唯一的IP地址和端口号组合，经过三次握手建立，有不同的状态，用于在计算机之间进行可靠的数据传输。

2.你知道TCP的连接是如何建立，又是如何关闭的吗？

**TCP连接建立（三次握手）：**

\1. **第一步**：客户端向服务器发送一个带有SYN（同步序列编号）标志的TCP包，这个包包含了客户端的初始序列号（ISN）。这表示客户端想要建立连接。此时，客户端进入SYN_SENT状态。

\2. **第二步**：服务器接收到客户端的SYN包后，会回应一个带有SYN和ACK（确认）标志的TCP包，也包含服务器的初始序列号。这个包表示服务器接受了连接请求。此时，服务器进入SYN_RECEIVED状态。

\3. **第三步**：客户端收到服务器的响应后，发送一个带有ACK标志的TCP包，确认服务器的确认。这样，连接建立完毕，客户端和服务器都进入ESTABLISHED状态，可以开始数据传输。

**TCP连接关闭（四次挥手）：**

\1. **第一步**：当一方（通常是客户端或服务器）想要关闭连接时，它发送一个带有FIN（结束）标志的TCP包，表示它不再发送数据。此时，发送方进入FIN_WAIT_1状态。

\2. **第二步**：接收方收到带有FIN标志的包后，发送一个带有ACK标志的包，确认收到FIN。此时，发送方进入FIN_WAIT_2状态。接收方也会进入CLOSE_WAIT状态，表示它正在等待应用程序处理完所有数据。

\3. **第三步**：当接收方完成数据处理后，它也发送一个带有FIN标志的包，表示它也要关闭连接。此时，接收方进入LAST_ACK状态，而发送方接收到这个包后进入TIME_WAIT状态，等待一段时间以确保任何延迟的数据都能被处理。

\4. **第四步**：最后，发送方发送一个带有ACK标志的包，确认接收到接收方的FIN包。一旦这个ACK包被接收方确认，连接被完全关闭，发送方退出TIME_WAIT状态。

这个过程确保了TCP连接的可靠关闭，防止数据丢失或重复。

### 6.2 TCP
直播协议多使用RTMP，而这个RTMP协议是基于TCP的。
#### TCP的拥塞控制导致的问题
当网络不好的时候，TCP协议会主动降低发送速度，这对本来当时就卡的看视频来讲是要命的，应该应用层马上重传，而不是主动让步。因而，很多直播应用，都基于UDP实现了自己的视频传输协议。
#### TCP的强顺序问题:
TCP的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着。

#### TCP包头格式
如图:

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/a795461effcce686a43f48e094c9adbf.jpg)

各各部分的作用:
1.源端口号和目标端口号:标识通信的两个应用
2.包的序号:解决乱序问题
3.确认序号:解决丢包的问题
4.状态位:SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接
5.窗口大小:通信双方各声明一个窗口，标识自己当前能够的处理能力，进行流量控制

首先，源端口号和目标端口号是不可少的，这一点和UDP是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。

接下来是包的序号。为什么要给包编号呢？当然是为了解决乱序的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。编号是为了解决乱序问题。

还应该有的就是确认序号。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以解决丢包的问题。

接下来有一些状态位。例如SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接等。TCP是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是窗口大小。TCP要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。
#### TCP的三次握手

三次握手的目的：

- 双方建立连接
- 沟通TCP包的序号的问题

##### 1.双方建立连接

A要向B发起一个连接，当发了第一个请求杳无音信的时候，会有很多的可能性，比如:

1. 第一个请求包丢了
2. 请求绕了弯路，超时了
3. B没有响应这个请求，不想和A连接
4. B已经挂了

A不能确认结果，于是再发，再发。B收到了请求包，就知道了A的存在，并且知道A要和它建立连接。如果B不乐意建立连接，则A会重试一阵后放弃，连接建立失败，没有问题；如果B是乐意建立连接的，则会发送应答包给A。

**一个诡异的现象**就是，A和B原来建立了连接，做了简单通信后，结束了连接。还记得吗？A建立连接的时候，请求包重复发了几次，有的请求包绕了一大圈又回来了，B会认为这也是一个正常的的请求的话，因此建立了连接，可以想象，这个连接不会进行下去，也没有个终结的时候，纯属单相思了。**因而两次握手肯定不行**。**(A请求包的重复发送导致的)**

为什么是三次？
因为三次能够使a与b的消息都是有去有回的。

在大部分情况下，A和B建立了连接之后，A会马上发送数据的，一旦A发送数据，则很多问题都得到了解决。例如A发给B的应答丢了，当A后续发送的数据到达的时候，B可以认为这个连接已经建立(于是能够保证数据的可靠性，不需要三次以上的握手)，或者B压根就挂了，A发送的数据，会报错，说B不可达，A就知道B出事情了。当然你可以说A比较坏，就是不发数据，建立连接后空着。我们在程序设计的时候，可以要求开启**keepalive机制**，即使没有真实的数据包，也有**探活包**。



##### 2.沟通TCP包的序号的问题

A要告诉B，我这面发起的包的序号起始是从哪个号开始的，B同样也要告诉A，B发起的包的序号起始是从哪个号开始的。每个连接都要有不同的序号(通常称为**ISN**（Initial Sequence Number）。这个ISN可以是一个随机数或基于某些算法生成的值。)。这个序号的起始序号是**随着时间变化的**，可以看成一个32位的计数器，每4ms加一。为什么序号不能都从1开始呢？因为这样往往会出现冲突。



双方终于建立了信任，建立了连接。前面也说过，为了维护这个连接，双方都要**维护一个状态机**，在连接建立的过程中，双方的状态变化时序图就像这样。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/666d7d20aa907d8317af3770411f5aa2.jpg)

一开始，客户端和服务端都处于CLOSED状态。先是服务端主动监听某个端口，处于LISTEN状态。然后客户端主动发起连接SYN，之后处于SYN-SENT状态。服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了。服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了。



#### TCP四次挥手

断开连接的时候的**状态时序图**。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/1f6a5e17b34f00d28722428b7b8ccb11.jpg)

断开的时候，我们可以看到，当A说“不玩了”，就进入FIN_WAIT_1的状态，B收到“A不玩”的消息后，发送知道了，就进入CLOSE_WAIT的状态。

A收到“B说知道了”，就进入FIN_WAIT_2的状态，如果这个时候B直接跑路，则A将**永远在这个状态**。TCP协议里面并没有对这个状态的处理，但是Linux有，可以调整tcp_fin_timeout这个参数，设置一个超时时间。

如果B没有跑路，发送了“B也不玩了”的请求到达A时，A发送“知道B也不玩了”的ACK后，从FIN_WAIT_2状态结束，按说A可以跑路了，但是最后的这个ACK万一B收不到呢？则B会重新发一个“B不玩了”，这个时候A已经跑路了的话，B就再也收不到ACK了，因而TCP协议要求A最后等待一段时间TIME_WAIT，这个时间要足够长，长到如果B没收到ACK的话，“B说不玩了”会重发的，A会重新发一个ACK并且足够时间到达B。A直接跑路还有一个问题是，A的端口就直接空出来了，但是B不知道，B原来发过的很多包很可能还在路上，如果A的端口被一个新的应用占用了，这个新的应用会收到上个连接中B发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来B发送的所有的包都死翘翘，再空出端口来。

等待的时间设为2MSL，**MSL**是**Maximum Segment Lifetime**，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为TCP报文基于是IP协议的，而IP头中有一个TTL域，是IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。协议规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。

还有一个异常情况就是，B超过了2MSL的时间，依然没有收到它发的FIN的ACK，怎么办呢？按照TCP的原理，B当然还会重发FIN，这个时候A再收到这个包之后，A就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送**RST**，B就知道A早就跑了。



#### TCP状态机

将连接建立和连接断开的两个时序状态图综合起来，就是这个著名的TCP的状态机。

TCP连接在传输层有多个状态，通常通过TCP状态机来表示。这些状态包括但不限于：CLOSED（关闭）、LISTEN（监听）、SYN_SENT（已发送同步请求）、SYN_RECEIVED（已接收同步请求）、ESTABLISHED（已建立连接）、FIN_WAIT_1（等待对方的FIN包）、FIN_WAIT_2（等待对方的FIN包，但自己还有数据要发送）、CLOSE_WAIT（等待应用程序关闭连接）、CLOSING（表示同时发送FIN包，等待对方的ACK确认）、TIME_WAIT（等待足够长的时间以确保最后的ACK被接收）、LAST_ACK（等待对方的最后一个ACK）等等。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/dab9f6ee2908b05ed6f15f3e21be88ab.jpg)

在这个图中，加黑加粗的部分，是上面说到的主要流程，其中阿拉伯数字的序号，是连接过程中的顺序，而大写中文数字的序号，是连接断开过程中的顺序。加粗的实线是客户端A的状态变迁，加粗的虚线是服务端B的状态变迁。

#### 小结

1.TCP包头很复杂，但是主要关注五个问题，
- 顺序问题(包的序号)
- 丢包问题(确认序号)
- 连接维护(状态位)
- 流量控制(窗口大小)
- 拥塞控制

2.连接的建立是经过三次握手，断开的时候四次挥手，一定要掌握的我画的那个状态图。

#### 思考题与gpt回答

1.TCP的连接有这么多的状态，你知道如何在系统中查看某个连接的状态吗？

在Linux或Unix系统中，您可以使用`netstat`或`ss`命令来查看TCP连接的状态：

~~~sh
netstat -tuln    # 列出所有TCP监听状态的连接
netstat -tun     # 列出所有TCP连接的状态
~~~

在Windows系统中，您可以使用`netstat`命令：

~~~sh
netstat -an    # 列出所有TCP连接的状态
~~~

2.这一节仅仅讲了连接维护问题，其实为了维护连接的状态，还有其他的数据结构来处理其他的四个问题，那你知道是什么吗？


维护TCP连接状态涉及许多数据结构和算法，用于处理TCP连接的不同阶段和相关问题。四个主要问题通常是：

1. 连接建立：在此阶段，数据结构用于跟踪客户端和服务器之间的握手过程，以确保双方能够建立连接。这通常涉及使用队列或表来存储等待建立连接的请求，例如SYN队列。
2. 连接维护：一旦连接建立，需要数据结构来跟踪连接的状态，以确保数据正确传输。这包括跟踪序列号、确认号、窗口大小等。通常，连接状态信息会存储在连接表中。
3. 连接释放：当连接关闭时，需要数据结构来管理TCP连接的终止过程。这可能包括等待关闭连接的定时器，以确保所有数据都已传输和确认。连接释放状态也可能包括等待确认的FIN包或ACK包。
4. 连接中断：如果在通信过程中出现错误或连接中断，数据结构用于处理连接恢复或重新建立连接。

这些问题通常由操作系统的TCP/IP协议栈处理，具体的数据结构和算法可能因操作系统而异。一般情况下，连接表、队列、定时器等数据结构和算法在TCP连接的各个阶段都起着重要作用，以确保可靠的数据传输和连接管理。不同的操作系统可能会使用不同的内部数据结构来管理TCP连接状态，但它们都需要有效地处理这四个主要问题。



#### TCP的滑动窗口(rwnd)

为了保证顺序性，每一个包都有一个ID。在建立连接的时候，会商定起始的ID(SYN)是什么，然后按照ID一个个发送。

为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的ID，表示这个ID之前的包都收到了，这种模式称为**累计确认**或者**累计应答**（**cumulative acknowledgment**）。

为了记录所有发送的包和接收的包，TCP也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的ID一个个排列，在TCP里，接收端会给发送端报一个窗口的大小，叫**Advertised window**。这个窗口的大小就是已经交代了没做完的加上马上要交代的。超过这个窗口的，接收端做不过来，就不能发送了。

于是，发送端需要保持下面的数据结构。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/16dcd6fb8105a1caa75887b5ffa0bd7b.jpg)

对于接收端来讲，它的缓存里记录的内容要简单一些。

对应的数据结构就像这样。 ﻿﻿![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/f7b1d3bc6b6d8e55f0951e82294c8ba4.jpg)

- MaxRcvBuffer：最大缓存的量；
- LastByteRead之后是已经接收了，但是还没被应用层读取的；

其中第二部分里面，由于收到的包可能不是顺序的，中间就会出现空挡，只有和第一部分连续的才可以马上进行回复，中间空着的部分需要等待，哪怕后面的已经来了。



#### **确认与重传的机制**:

重传的三种方式：

1.**超时触发重传**：即对每一个发送了，但是没有ACK的包，都有设一个定时器，超过了一定的时间，就重新尝试。

但是这个**超时的时间如何评估呢？**这个时间不宜过短，时间必须大于往返时间RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。估计往返时间，需要TCP通过采样RTT的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化。除了采样RTT，还要采样RTT的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为**自适应重传算法**（**Adaptive Retransmission Algorithm**）。

**超时间隔加倍**：**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍**。**两次超时，就说明网络环境差，不宜频繁反复发送。**

2.有一个可以**快速重传**的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。例如，接收方发现6、8、9都已经接收了，就是7没来，那肯定是丢了，于是**发送三个6的ACK，要求下一个是7**。客户端收到3个，就会发现7的确又丢了，不等超时，马上重发。

3.**Selective Acknowledgment** （**SACK**）。这种方式需要在TCP头里加一个SACK的东西，可以将缓存的地图发送给发送方。例如可以发送ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是7丢了。



#### 流量控制机制

在对于包的确认中(发送**确认信息**给发送方)，同时**会携带一个滑动窗口(rwnd)的大小**。

如果接收方实在处理的太慢，导致缓存中没有空间了，可以通过在确认信息中修改窗口的大小，甚至可以设置为0，则发送方将暂时停止发送。

发送端的窗口为0时，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小。当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。

#### 拥塞控制问题 拥塞窗口(cwnd)

滑动窗口rwnd是怕发送方把接收方缓存塞满，而拥塞窗口cwnd，是怕把网络塞满。

水管有粗细，网络有带宽，也即每秒钟能够发送多少数据；水管有长度，端到端有时延。在理想状态下，水管里面水的量=水管粗细 x 水管长度。对于到网络上，通道的容量 = 带宽 × 往返延迟。



TCP的拥塞控制主要来**避免两种现象**，**包丢失**(设备只能每秒处理一个包，多出来的包就会被丢弃)和**超时重传**(在缓存中排队，时延达到一定程度)。一旦出现了这些现象就说明，发送速度太快了，要慢一点。

一条TCP连接开始，cwnd设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd加一，于是一次能够发送两个(1,2,4,8...);一开始为：**指数性的增长**，有一个值ssthresh为65535个字节，当超过这个值的时候，每收到一个确认后，cwnd增加1/cwnd(其实就是加1)，变成了**线性增长。**

拥塞的一种表现形式是丢包，需要超时重传，这个时候，将sshresh设为cwnd/2，将cwnd设为1，重新开始**慢启动**。这真是一旦超时重传，马上回到解放前。

使用**快速重传算法**时。当接收端发现丢了一个中间包的时候，发送三次前一个包的ACK，要求下一个包为丢失的包，于是发送端就会快速的重传，不必等待超时再重传。此时cwnd（20）减半为cwnd/2（10），然后sshthresh = cwnd（10），当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/1910bc1a0048d4de7b2128eb0f5dbcd2-1584286484075.jpg)

TCP的拥塞控制主要来避免的两个现象都是有问题的：

**第一个问题**是丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。

**第二个问题**是TCP的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实TCP只要填满管道就可以了，不应该接着填，直到连缓存也填满。

为了优化这两个问题，后来有了**TCP BBR拥塞算法**。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。

![img](https://lianglianglee.com/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4/assets/a2b3a5df5eca52e302b75824e4bbbd4c-1584286500709.jpg)

1. TCP的BBR听起来很牛，你知道他是如何达到这个最优点的嘛？
2. 学会了UDP和TCP，你知道如何基于这两种协议写程序吗？这样的程序会有什么坑呢？
