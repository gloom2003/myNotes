# 二分搜索 时间复杂度：O(log n)

## 1 关于while 循环的条件设置

关于**while 循环的条件**是<还是<=

使用左闭右闭区间时，定义搜索区间为 [left, right],初始化：

~~~java
public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
    	while(left <= right){
            
        }
}
~~~

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候搜索区间为空，已经全部搜索过了**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空,还有元素没有被搜索**，还有一个数 2，但此时 while 循环终止了。也就是说区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

使用左闭右开区间时，定义搜索区间为 [left, right),初始化：

~~~java
public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
    }
~~~

**while 循环的条件与左闭右闭的相反，你有=我就没有。**

```java
while(left < right){
    
}// 因为left == right的时候，在[left, right)是无效的空间
```

## 2 二分查找框架

#### 思路：

就是定义二分搜索的**搜索区间**，根据条件不断的**减半**搜索区间

#### tips：

while循环条件使用,左闭右闭的情况推即可。

左闭**右闭**的搜索区间没有坑，找左侧边界的索引返回left,找右侧边界的索引返回right

左闭**右开**的搜索区间有坑，找左侧边界的索引返回left,找右侧边界的索引返回right**-1**

### 2.1 二分查找基本框架



```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

### 2.2 查找一个数target的框架

#### 使用前提
数组为**有序**数组(这里是针对升序数组的写法)，同时题目还强调**数组中无重复元素**



#### 2.2.1 搜索区间为 [left, right] 大一统模版

~~~java
int binarySearch(int[] nums, int target) {
    if(nums == null){
            return -1;
    }
    //定义搜索区间为 [left, right]
    int left = 0; 
    int right = nums.length - 1; // 注意
	//while停止时：即：left=right+1时,[left,right] -> [right+1,right],为空,说明nums的所有元素但已经完成检查
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            return mid; 
        }
        else if (nums[mid] < target){
            //更新搜索区间
            left = mid + 1;
        }
							//注意 当我们发现nums[mid]不是要找的 target 时，下一步应该去搜索哪里呢？
							//当然是去搜索区间 [left, mid-1] 或者区间 [mid+1, right] 对不对？因为 mid 已经搜索过，应								  该从搜索区间中去除。
        else if (nums[mid] > target){
            right = mid - 1; // 注意
        }
    }
    return -1;
}

~~~

#### 2.2.2 搜索区间为 [left, right)

~~~java
int binarySearch(int[] nums, int target) {
    if(nums == null){
            return -1;
    }
    //定义搜索区间为 [left, right)
    int left = 0; 
    int right = nums.length; // 注意
	//while停止时：即left=right时,[left,right) -> [left,left),为空,说明nums的所有元素但已经完成检查
    while(left < right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            return mid; 
        }
        else if (nums[mid] < target){
            //更新搜索区间
            left = mid + 1;
        }
        else if (nums[mid] > target){
            right = mid; // 注意
        }
    }
    return -1;
}
~~~



### 2.3 寻找左侧边界的二分搜索

#### 2.3.1 搜索区间为 [left, right] 大一统模版


~~~java
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            //搜索区间向左靠
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中(target的值过大则会越界)
    // 如果越界，target 肯定不存在，返回 -1
    if (left < 0 || left >= nums.length) {
        return -1;
    }
    // 上面就是把left这个索引移动到合适的位置，nums[mid] == target时没有进行return,所以走到这里的不一定等于target,在这里判断一下 nums[left] 是不是等于 target           
    // 为什么是nums[left]？
    // 简洁：寻找左侧边界所以返回left
    // 详细：(搜索区间全部都是target时，nums[mid] == target 右侧边界一直在向左压缩,right减少到 left ==right时，仍然符合nums[mid] == target，再次执行right = mid - 1;nums[right]的值就不等于target了，而left仍然等于target)
    return nums[left] == target ? left : -1;
}

~~~



#### 2.3.2 搜索区间为 [left, right) 

~~~java
int left_bound(int[] nums, int target) {
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            //搜索区间向左靠
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    // 判断 target 是否存在于 nums 中
    // 如果越界，target 肯定不存在，返回 -1
    if (left < 0 || left >= nums.length) {
        return -1;
    }
    // 判断一下 nums[left] 是不是 target  注意： left不需要-1
    return nums[left] == target ? left : -1;
}

~~~

### 2.4 寻找右侧边界的二分搜索

#### 2.4.1 搜索区间为 [left, right] 大一统模版

~~~java
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            //搜索区间向右靠
            left = mid + 1; // 注意
        }
    }
    // 判断 target 是否存在于 nums 中(target的值过小则会越界)
    // 如果越界，target 肯定不存在，返回 -1
    // 良好习惯，上下边界都进行判断
    if (right < 0 || right >= nums.length) {
        return -1;
    }
    // 判断一下 nums[left] 是不是 target           
    // 为什么是nums[right]？
    // 寻找右侧边界所以返回right
    return nums[right] == target ? right : -1;
}

~~~



#### 2.4.2 搜索区间为 [left, right)

~~~java
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length;
    // 搜索区间为 [left, right)
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right)
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid)
            right = mid;
        } else if (nums[mid] == target) {
            //搜索区间向右靠
            left = mid + 1; // 注意
        }
    }
    //因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。又因为while 循环结束时left=right,所以left可以全部替换为right
    
    // 判断 target 是否存在于 nums 中(target的值过小则会越界)
    // 如果越界，target 肯定不存在，返回 -1
    // 良好习惯，上下边界都进行判断
    if (right-1 < 0 || right-1 >= nums.length) {
        return -1;
    }
    // 判断一下 nums[left] 是不是 target           
    // 为什么是nums[right]？
    // 寻找右侧边界所以返回right,  注意： 因为有开区间并且寻找右侧边界，所以-1 
    return nums[right-1] == target ? right-1 : -1;
}

~~~

## 3 二分框架的使用

### 3.1 在排序数组中查找元素的第一个和最后一个位置(leetcode)

https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/

my100% O(log n) 直接使用二分搜索左右边界的框架即可ak。

~~~java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if(nums == null || nums.length == 0){
            return new int[]{-1,-1};
        }
        int left = leftBorder(nums,target);
        int right = rightBorder(nums,target);
        return new int[]{left,right};
    }

    public int leftBorder(int[] nums, int target){
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            // 注意：+的优先级比>>高，所以需要括号
            int mid = left + ((right - left) >> 2);
            if(target > nums[mid]){
                left = mid + 1;
            }else if(target < nums[mid]){
                right = mid - 1;
            }else if(target == nums[mid]){
                right = mid - 1;
            }
        }
        if(left < 0 || left >= nums.length){
            return -1;
        }
        return nums[left] == target ? left : -1;
    }

    public int rightBorder(int[] nums, int target){
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            int mid = left + ((right - left) >> 2);
            if(target > nums[mid]){
                left = mid + 1;
            }else if(target < nums[mid]){
                right = mid - 1;
            }else if(target == nums[mid]){
                left = mid + 1;
            }
        }
        if(right < 0 || right >= nums.length){
            return -1;
        }
        return nums[right] == target ? right : -1;
    }
}
~~~



## 4 二分搜索的实际应用-找到单调函数 f(x)

二分搜索的套路比较固定，如果遇到一个算法问题，能够确定 `x, f(x), target` 分别是什么，并写出单调函数 `f` 的代码，那么就可以运用二分搜索的思路求解。

[leetcode题目]: https://leetcode.cn/problems/koko-eating-bananas/description/

这题珂珂吃香蕉的速度 `K` 就是自变量 `x`，吃完所有香蕉所需的时间就是单调函数 `f(x)`，`target` 就是吃香蕉的时间限制 `H`。我们需要调整 速度`x`，使得 吃完所有香蕉所需的时间`f(x)` 尽可能接近 时间限制`target`，也就是说，我们需要找到最小的 `x`，使得 `f(x) <= target`。

它们的关系如下图：



![img](https://labuladong.github.io/pictures/%E4%BA%8C%E5%88%86%E8%BF%90%E7%94%A8/4.jpeg)

随着速度x的增加，吃完所有香蕉所需的时间`f(x)`不断递减，当f(x)=时间限制H时，有多个x符号要求，需要的是其中最小的x。



具体代码如下：

~~~java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        //定义搜索区间为速度k的取值范围
        int left = 1;
        //最快速度为：1000000000(一堆香蕉的最大值)，就算速度超出了这个值
        //在一小时里吃掉的香蕉仍然不会改变
        int right = 1000000000 + 1;
        //二分搜索左闭右开
        while(left < right){
            int mid = left + (right-left)/2;
            if(f(piles,mid) > h){
                //mid这个速度花费是时间太久了，要加快速度
                left = mid + 1;
            }else if(f(piles,mid) < h){
                right = mid;
            }else if(f(piles,mid) == h){
                //寻找左边界，即最小速度
                right = mid;
            }
        }
        return left;
    }
    // h = f(k) 输入速度k返回吃完所花费的时间h
    private int f(int[] piles,int k){
        int h = 0;
        for(int i = 0;i<piles.length;i++){
            //先除后模(大概计算出piles[i]是k的几倍)
            h += piles[i] / k;
            if(piles[i] % k > 0){
                h++;
            }
        }
        return h;
    }
}
~~~

