# 排序算法

## 1 冒泡排序

### **要求**

* 能够用自己语言描述冒泡排序算法
* 能够手写冒泡排序代码
* 了解一些冒泡排序的优化手段

### **算法描述**

1. 依次比较数组中相邻两个元素大小，若 第i个元素 > 第i+1个元素，则交换两个元素，**把数组中的元素都两两都比较一遍称为一轮冒泡**，一轮冒泡的结果是让最大的一个元素排至最后
2. 重复以上步骤，直到整个数组有序

> *更形象的描述请参考：bubble_sort.html*

### **算法实现与优化**

```java
public static void bubble(int[] a) {
    // 重复a.length - 1次冒泡
    for (int j = 0; j < a.length - 1; j++) {
        // 一轮冒泡
        boolean swapped = false; // 优化1：是否发生了交换
        for (int i = 0; i < a.length - 1 - j; i++) { // 优化2
            System.out.println("比较次数" + i);
            if (a[i] > a[i + 1]) {
                Utils.swap(a, i, i + 1);
                swapped = true;
            }
        }
        System.out.println("第" + j + "轮冒泡"
                           + Arrays.toString(a));
        if (!swapped) {
            break;
        }
    }
}
```

* 优化点1：每经过一轮冒泡，内层循环就可以减少一次
* 优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环

**进一步优化**

```java
public static void bubble_v2(int[] a) {
    int n = a.length - 1; // 下一轮冒泡的比较次数
    // 无限循环
    while (true) {
        int last = 0; // 表示最后一次交换索引位置
        // 一次冒泡
        for (int i = 0; i < n; i++) {
            System.out.println("比较次数" + i);
            if (a[i] > a[i + 1]) {
                Utils.swap(a, i, i + 1);
                last = i;
            }
        }
        n = last; // 最后一次交换时的索引可以作为下一轮冒泡的比较次数
        System.out.println("第轮冒泡"
                           + Arrays.toString(a));
        if (n == 0) { // 下一轮冒泡的比较次数为0时，排序完成
            break;
        }
    }
}
```

* 每轮冒泡时，**最后一次交换时的索引可以作为下一轮冒泡的比较次数**，如果这个值为零，表示整个数组有序，直接退出外层循环即可



## 2 选择排序

### **要求**

* 能够用自己语言描述选择排序算法
* 能够比较选择排序与冒泡排序
* 理解非稳定排序与稳定排序

### **算法描述**

1. 将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中**选择最小的元素**存放到排序区域中，这样一轮排序的结果就是从小到大的排好一个数

2. 重复以上步骤，直到整个数组有序

### 实现与优化

~~~java
public class SelectSort {
    public static void main(String[] args) {
        int[] arr = new int[]{1,2,4,3,6,5,7};
        selectSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 选择排序，把数组分为两个子集，排好序的和未排序的，每次从未排序的子集中寻找最小的元素存放到排好序的子集中，
     * 重复以上步骤，直到整个数组有序
     * @param arr
     */
    private static void selectSort(int[] arr) {
        for(int i = 0;i < arr.length - 1;i++){
            // i为被替换的目标元素
            int min = i;
            for(int j = min + 1;j < arr.length;j++){
                // j去前面探路，寻找小于arr[min]的元素的索引，并且赋值给min，遍历完后min指向的就是未排序区域中最小的元素了
                if(arr[j] < arr[min]){
                    min = j;
                }
            }
            // 如果最小元素的索引不是i，则交换
            if(min != i){
                int temp = arr[i];
                arr[i] = arr[min];
                arr[min] = temp;
            }
        }
    }
}

~~~

* 优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素

### **与冒泡排序比较**

1. 从速度上看，二者平均时间复杂度都是 $O(n^2)$，但选择排序一般要快于冒泡，因为其交换次数少。但如果集合有序度高，冒泡优于选择。
2. 从实现的方式来看，选择排序的方式是依次把第一小、第二小...的元素存放在左边，来实现升序。冒泡排序的方式是依次把第一大、第二大...的元素存放在右边，来实现升序。
3. 从稳定性方面来看，冒泡属于稳定排序算法，而选择属于不稳定排序
   * 稳定排序指，按对象中**不同字段**进行多次排序，不会打乱同值元素的**相对顺序**
   * 不稳定排序则反之

都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ...）

* 不稳定排序算法按数字排序时，会打乱原本同值的花色的相对顺序

  ```
  [[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]
  [[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]
  ```

  原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了

* 稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变

  ```
  [[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]
  [[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]
  ```

  

## 3 2级 插入排序

### **要求**

* 能够用自己语言描述插入排序算法
* 能够比较插入排序与选择排序

### **算法描述**

1. 将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，**插入**到排序区域（需保证按顺序进行插入），每轮排序的结果为插入好一个元素。

2. 重复以上步骤，直到整个数组有序

### **算法实现**

```java
public class InsertSort {
    public static void main(String[] args) {
        int[] a = {7, 5, 19, 8, 4, 1};
        insertSort(a);
        System.out.println(Arrays.toString(a));
    }

    public static void insertSort(int[] arr){
        //从第二个元素遍历到最后一个元素，对遍历的每一个元素进行插入
        //  注意：是从第二个元素开始遍历！
        for(int i = 1;i < arr.length;i++){
            int val = arr[i];// val表示要插入的元素的值
            int j = i;
            // 寻找合适的位置进行插入
            while(j >= 1){
                // 如果前一个元素比要插入的元素更大，则向右移
                if(arr[j - 1] > val){
                    arr[j] = arr[j - 1];
                    j--;
                }else{
                    // 如果前一个元素已经 <= 要插入的元素了，那么此时的j就是要插入的位置
                    break;
                }
            }
            // 插入
            arr[j] = val;
        }
    }
}
```

或者：

~~~java
public static void main(String[] args) {
        int[] arr = {2,5,2,1,0,8,6,2,9,};
        myInsertSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 插入排序
     * @param arr
     */
    private static void insertSort(int[] arr) {
        //把数组分成两部分，第一个数已经排好序了，遍历剩下的每一个没有排好序的数
        for(int i = 1;i<arr.length;i++){
            //没有排好序部分的第一个数,作为哨兵要插入到排好序的部分中
            int num = arr[i];
            //指向已经排好序部分的最后一个数
            int j = i-1;
            //从后往前遍历排好序的数组，给哨兵找到插入位置(即:退出循环后的j+1)
            while(j>=0 && num < arr[j]){
                arr[j+1] = arr[j];
                j--;
            }
            arr[j+1] = num;
        }
    }
~~~



### **与选择排序比较**

1. 二者平均时间复杂度都是 $O(n^2)$

2. 大部分情况下，插入都略优于选择

3. 有序集合插入的时间复杂度为 $O(n)$

4. 插入属于稳定排序算法，而选择属于不稳定排序

**提示**

> *插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序*



总结：

一般情况下： 插入排序(稳定) > 选择排序(不稳定) > 冒泡排序(稳定) ，平均时间复杂度都是 O(n^2)

- 选择排序一般要快于冒泡，因为其交换次数少。
- 如果集合有序度高，冒泡优于选择，此时插入排序的时间复杂度为 $O(n)$。
- 大部分情况下，插入都略优于选择

##  4 希尔排序

#### **要求**

* 能够用自己语言描述希尔排序算法

#### **算法描述**

my:

把待排序的元素分成数量相同的几组(可以是2组、4组...),一组的数量记为间隙gap,在一组中，对后面的组以前面的组**对应的组内元素为标准**进行**插入排序**（就好像标准的插入排序以第一个元素为标准一样）,每次排序后令间隙gap减半，当间隙gap逐渐减少，直至**为 1 时，执行的就是标准的插入排序**，执行完成后即可完成排序

三更：

1. 首先选取一个间隙序列，如gap =  (n/2，n/4 … 1)，n 为数组长度

2. 每一轮将间隙相等的元素视为一组，在一组中，对后面的序列以前面的序列**对应的组内元素为标准**进行**插入排序**（就好像标准的插入排序以第一个元素为标准一样），**目的有二**

   ① 少量元素插入排序速度很快

   ② 让组内值较大的元素更快地移动到后方(对插入排序的增强、优化?)

   如：

   ~~~java
   [7, 5, 19, 8, 4, 1] gap:3 // 操作前
   [7, 4, 19, 8, 5, 1] gap:3 // 5与4交换
   [7, 4, 1, 8, 5, 19] gap:3 // 操作后 1与19交换
   ~~~

   

3. 当间隙gap逐渐减少，直至**为 1 时，执行的就是标准的插入排序**，执行完成即可完成排序

> *更形象的描述请参考：shell_sort.html*



#### **算法实现**

初始：

~~~java
    // 标准插入排序
	private static void shellSort(int[] arr) {
        int gap = 1;
        // 插入排序，从索引gap开始遍历
        for(int i = gap;i < arr.length;i++){
            int val = arr[i];
            int j = i;
            // 寻找插入的位置
            while(j >= gap){
                if(arr[j - gap] > val){
                    // 右移
                    arr[j] = arr[j - gap];
                    j -= gap;
                }else{
                    break;
                }
            }
            // 插入
            arr[j] = val;
        }
    }
~~~

my:

~~~java
    private static void shellSort(int[] arr) {
        int n = arr.length;
        // 无论n是奇数还是偶数，gap一直除以2，一定会经历 gap = 1,
        // 即：一定会经历标准的插入排序,前面经历的都是给这个插入排序进行铺垫，为了这次排序更快的完成
        for(int gap = n / 2;gap > 0;gap/=2){
            // 插入排序，从索引gap开始遍历
            for(int i = gap;i < n;i++){
                int val = arr[i];
                int j = i;
                // 寻找插入的位置
                while(j >= gap){
                    if(arr[j - gap] > val){
                        // 右移
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }else{
                        break;
                    }
                }
                // 插入
                arr[j] = val;
            }
        }
    }
~~~



三更：

```java
private static void shell(int[] a) {
    int n = a.length;
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // i 代表待插入元素的索引 gap不断减半，待变为1时，即是普通的插入排序
        for (int i = gap; i < n; i++) {
            int t = a[i]; // 代表待插入的元素值
            int j = i;
            // 寻找插入的位置,与插入排序类似
            while (j >= gap) {
                // 每次与上一个间隙为 gap 的元素进行插入排序
                if (t < a[j - gap]) { // j-gap 是上一个元素索引，如果 > t，后移
                    a[j] = a[j - gap];
                    j -= gap;
                } else { // 如果 j-1 已经 <= t, 则 j 就是插入位置
                    break;
                }
            }
            // 插入
            a[j] = t; // 整个过程相当于交换了两个元素
            System.out.println(Arrays.toString(a) + " gap:" + gap);
        }
    }
}
```





##  5 快速排序 

### **要求**

* 能够用自己语言描述快速排序算法
* 掌握手写单边循环、双边循环代码之一
* 能够说明快排特点
* 了解洛穆托与霍尔两种分区方案的性能比较

### **算法描述**

my:

1. 每一轮排序选择一个基准点（pivot）进行分区,让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区（根据升序、降序来选择） **分区算法的选择：常见的具体实现有洛穆托分区方案（选择最右边的作为pivot）、双边循环分区方案（选择最左边的作为pivot）、霍尔分区方案**
2. 在子分区内**递归的重复**以上过程，**直至子分区元素个数少于等于 1**，我们就完成了快速排序（这体现的是**分而治之**的思想）



### **单边循环快排（lomuto 洛穆托分区方案）**

1. 选择最右元素作为基准点元素

2. j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换

3. i 指针维护小于基准点元素的边界，也是每次交换的目标索引

4. 最后基准点与 i 交换，i 即为分区位置

```java
public static void quick(int[] a, int l, int h) {
    if (l >= h) {
        return;
    }
    int p = partition(a, l, h); // p 索引值
    quick(a, l, p - 1); // 左边分区的范围确定
    quick(a, p + 1, h); // 左边分区的范围确定
}

private static int partition(int[] a, int l, int h) {
    int pv = a[h]; // 基准点元素
    int i = l;
    for (int j = l; j < h; j++) {
        if (a[j] < pv) {
            if (i != j) {
                swap(a, i, j);
            }
            i++;
        }
    }
    if (i != h) {
        swap(a, h, i);
    }
    System.out.println(Arrays.toString(a) + " i=" + i);
    // 返回值代表了基准点元素所在的正确索引，用它确定下一轮分区的边界
    return i;
}
```



### **双边循环快排（不完全等价于 hoare 霍尔分区方案）**

① 寻找分区位置

1. 选择最左元素作为基准点元素
2. j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，二者一旦找到，就对二者进行交换，直至 i，j 相交
3. 最后基准点与 i（此时 i 与 j 相等,均可）交换，i 即为分区位置

② 对找到的两个分区递归的进行排序(拆分为子问题，分治?)

要点

1. 基准点在左边，并且**注意：要先 j 后 i,顺序不能改变，否则排序会失败** 

2. while( **i** **< j** && a[j] > pv ) j-- 
3. while ( **i** **< j** && a[i] **<=** pv ) i++    等于号在这里！！！

三更：

```java
// 递归函数的定义：输入待排序的数组与索引范围(左闭右闭的),把数组按照升序进行排序
private static void quick(int[] a, int l, int h) {
    if (l >= h) {
        return;
    }
    // 寻找分区位置
    int p = partition(a, l, h);
    // 对找到的两个分区递归的进行排序
    quick(a, l, p - 1);// 注意：索引范围中不包含p
    quick(a, p + 1, h);
}
// 寻找分区位置并返回
private static int partition(int[] a, int l, int h) {
    int pv = a[l]; // 选择最左元素作为基准点元素
    int i = l;
    int j = h;
    while (i < j) {
        // j 从右找小的  顺序不能更换
        while (i < j && a[j] > pv) { // 每次都需要判断一次 i < j
            j--;
        }
        // i 从左找大的
        while (i < j && a[i] <= pv) { // 等于号必须在这里 ！！！
            i++;
        }
        swap(a, i, j);
    }
    swap(a, l, j);// 此时，i == j,把基准点元素与循环停止时两个指针指向的值进行交换
    // System.out.println(Arrays.toString(a) + " j=" + j);
    return j;
}
```

my：

~~~java
 public static void main(String[] args) {
        int[] a = {5, 3, 7, 2, 9, 8, 1, 4};
        doubleQuickSort(a,0,a.length - 1);
        System.out.println(Arrays.toString(a));
    }

    private static void doubleQuickSort(int[] a, int l, int r) {
        if(l >= r){
            return;
        }
        // 寻找分区位置
        int pivot = findPivot(a,l,r);
        // 递归的进行排序
        doubleQuickSort(a,l,pivot - 1);
        doubleQuickSort(a,pivot + 1,r);
    }

    private static int findPivot(int[] a, int l, int r) {
        // 以最左边的元素作为第一次的pivot基准点
        int pivot = a[l];
        // 定义两个指针来进行遍历交换元素
        int i = l;
        int j = r;
        while(i < j){
            // 先从右边开始找，再找从左边找   顺序不能更换！！！
            while(i < j && a[j] > pivot){ // 每次都需要判断一次 i < j
                j--;
            }
            while(i < j && a[i] <= pivot){ // 等于号必须在这里！！！
                i++;
            }
            // 找到后就交换
            swap(a,i,j);
        }
        // i == j时退出，把两个指针停止时指向的值与一开始的pivot基准点进行交换
        swap(a,l,i);
        // 两个指针停止时指向的索引位置就是下一个pivot基准点
        return i;
    }
	// 交换方法， 最好定义一个
    private static void swap(int[] a, int h, int i) {
        int temp = a[h];
        a[h] = a[i];
        a[i] = temp;
    }
~~~



### **快排特点**

1. 平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$

2. 数据量较大时，优势非常明显

3. 属于不稳定排序

### **洛穆托分区方案 vs 霍尔分区方案**

* 霍尔的移动次数平均来讲比洛穆托少3倍
* https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto

> ***补充代码说明***
>
> * day01.sort.QuickSort3 演示了空穴法改进的双边快排，比较次数更少
> * day01.sort.QuickSortHoare 演示了霍尔分区的实现
> * day01.sort.LomutoVsHoare 对四种分区实现的移动次数比较

