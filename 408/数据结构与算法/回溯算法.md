# 回溯算法的原理和解题框架



## 1.基础知识

其实回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：回溯算法是在**遍历「树枝」**，DFS 算法是在遍历「节点」。



**抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案**。

站在回溯树的一个节点上，你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

这棵回溯树：

![img](https://labuladong.github.io/algo/images/backtracking/1.jpg)

只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。**我们不妨把这棵树称为回溯算法的「决策树」**。

**为啥说这是决策树呢，因为你在每个节点上其实都在做决策**。比如说你站在下图的红色节点上：

![img](https://labuladong.github.io/algo/images/backtracking/2.jpg)

你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。

**现在可以解答开头的几个名词：`[2]` 就是「路径」，记录你已经做过的选择；`[1,3]` 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层叶子节点，这里也就是选择列表为空的时候**。



可以把「路径」和「选择」列表作为决策树上每个节点的**属性**，比如下图列出了几个蓝色节点的属性：

![img](https://labuladong.github.io/algo/images/backtracking/3.jpg)

**我们定义的 `backtrack` 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层叶子节点，其「路径」就是一个全排列**。

**随着指针向下遍历，选择列表（可以做出的选择）不断减少，路径（已经做过的选择）不断增加。**



多叉树的遍历框架就是这样：

```java
void traverse(TreeNode root) {
    for (TreeNode child : root.childern) {
        // 前序位置需要的操作  做选择
        traverse(child); //   进入下一步决策
        // 后序位置需要的操作  撤销选择
    }
}
```

而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，画张图就明白了：

![img](https://labuladong.github.io/algo/images/backtracking/4.jpg)

**前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行**。

回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确处理节点的属性，那么就要在这两个特殊时间点搞点动作：

![img](https://labuladong.github.io/algo/images/backtracking/5.jpg)





### 





## 2. 排列、组合、子集问题



代码方面，**回溯算法统一的框架**：

```python
res = [] #记录最终的结果
track = [] # 路径：做出的选择
# 其他可能的变量： 全排列：boolean[] used;  组合之和等于target:int sum
def main(int nums[]){
    //处理特殊情况
    ...
    //回溯
    backTrack()
    return res
}
def backTrack(路径, 选择列表):  #可能为： backTrack(int[] nums,int start),backTrack(int[] nums)
    # 递归停止条件 遍历过程中满足条件时做什么事情
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        # 进入下一步决策
        backTrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**。

### 2.0 技巧总结：排列与子集（组合)问题

1.组合问题可以转换为子集问题，**组合和子集是一样的：大小为 `k` 的组合就是大小为 `k` 的子集**。

2.数据中可能有重复元素 -> 排序+减枝(i>start && nums[i]==nums[i-1]) 

其中i>start表示遍历子集回溯树的第一个分支时不进行判断

3.元素没有重复但是可以复选：把标准情况(元素无重复不可复选)的去重条件去除即可

#### ① 无重复元素、元素不可复选

backTrack函数的参数**肯定有 选择列表 与 路径**，无重复元素、元素不可复选的情况下：

全排列问题则添加一个boolean[] used来防止重复遍历

子集问题则添加一个int start 在调用backTrack函数时递增，从而保证元素相对顺序的一致性。

组合/子集问题使用 `start` 变量保证元素 `nums[start]` 之后只会出现 `nums[start+1..]` 中的元素，通过固定元素的相对位置保证不出现重复的子集。

但排列问题本身就是让你穷举元素的位置，`nums[i]` 之后也可以出现 `nums[i]` 左边的元素，所以之前的那一套玩不转了，需要额外使用 `used` 数组来标记哪些元素还可以被选择。



### 排列、组合、子集问题介绍

无论是排列、组合还是子集问题，简单说无非就是让你从序列 `nums` 中以给定规则取若干元素，主要有以下几种变体：

根据元素是否重复、元素是否可以重复选择：

**形式一、元素无重不可复选，即 `nums` 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式**。

以组合为例，如果输入 `nums = [2,3,6,7]`，和为 7 的组合应该只有 `[7]`。

**形式二、元素可重不可复选，即 `nums` 中的元素可以存在重复，每个元素最多只能被使用一次**。

以组合为例，如果输入 `nums = [2,5,2,1,2]`，和为 7 的组合应该有两种 `[2,2,2,1]` 和 `[5,2]`。

**形式三、元素无重可复选，即 `nums` 中的元素都是唯一的，每个元素可以被使用若干次**。

以组合为例，如果输入 `nums = [2,3,6,7]`，和为 7 的组合应该有两种 `[2,2,3]` 和 `[7]`。

当然，也可以说有第四种形式，即元素可重可复选。但既然元素可复选，那又何必存在重复元素呢？元素去重之后就等同于形式三，所以这种情况不用考虑。

上面用组合问题举的例子，但**排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。**

除此之外，题目也可以再添加各种限制条件，比如让你求和为 `target` 且元素个数为 `k` 的组合，那这么一来又可以衍生出一堆变体，

**但无论形式怎么变化，其本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽**。

记住如下**子集问题和排列问题的回溯树**，就可以解决所有排列组合子集相关的问题：

对于num = [1,2,3],我们通过**在排列树的基础上，**保证元素之间的**相对顺序不变**来防止出现**重复的子集**：

![img](https://labuladong.github.io/algo/images/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/1.jpeg)



排列树：

![img](https://labuladong.github.io/algo/images/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/2.jpeg)

**组合问题和子集问题其实是等价的，**组合和子集是一样的：大小为 `k` 的组合就是大小为 `k` 的子集**。；至于之前说的三种变化形式，无非是在这两棵树上剪掉或者增加一些树枝罢了**。

集合中的元素不用考虑顺序，[1,2]与[2,1]相同。



### 2.1 形式一:元素无重不可复选

，即 `nums` 中的元素都是唯一的，每个元素最多只能被使用一次，`backtrack` 核心代码如下：

```java
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}

/* 全排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
```

#### 例题：子集

https://leetcode.cn/problems/subsets/description/

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

解法1：labuladong 回溯20%

~~~java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    // 记录回溯算法的递归路径
    LinkedList<Integer> track = new LinkedList<>();// 也可以添加到backTrack函数的参数列表中

    // 主函数
    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, 0);
        return res;
    }

    // 回溯算法核心函数，遍历子集问题的回溯树
    void backtrack(int[] nums, int start) {// 添加start参数来

        // 每个节点的值都是一个子集 track每添加一个元素就记录一次结果
        res.add(new LinkedList<>(track));
        
        // 回溯算法标准框架
        for (int i = start; i < nums.length; i++) {
            // 做选择
            track.addLast(nums[i]);
            // 通过 start 参数控制树枝的遍历，保证元素的相对顺序来避免产生重复的子集(在[1,2]与[2,1]中选择前者)
            backtrack(nums, i + 1);// i + 1,而不是start + 1
            // 撤销选择
            track.removeLast();
        }
    }
}

~~~



#### 4级 例题：组合

思路：

解法1：my25% 回溯解决无重复、不可复选的组合问题

~~~java
class Solution {
    // 结果集
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        // 选择列表：[1-n]
        // 路径
        LinkedList<Integer> track = new LinkedList<>();
        // 回溯函数，参数：选择列表、路径、保证相对顺序、组合的大小
        backTrack(n,track,1,k);
        return res;
    }

    public void backTrack(int n,LinkedList track,int start,int k){
        // 路径的size为k时，记录结果 大小为k的组合等于大小为k的子集
        if(track.size() == k){
            res.add(new LinkedList(track));
            return;
        }
        for(int i = start;i <= n;i++){
            // 做选择
            track.addLast(i);
            // 回溯
            backTrack(n,track,i + 1,k);
            // 撤销选择
            track.removeLast();
        }
    }
}
~~~

解法2：提交记录的示例代码100%，修改后：

~~~java
class Solution {
    // 结果集
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        // 选择列表：[1-n]
        // 路径
        ArrayList<Integer> track = new ArrayList<>(); // 使用ArrayList作为实现类
        // 回溯函数，参数：选择列表、路径、保证相对顺序、组合的大小
        backTrack(n,track,1,k);
        return res;
    }

    public void backTrack(int n,ArrayList track,int start,int k){
        // 路径的size为k时，记录结果 大小为k的组合等于大小为k的子集
        if(track.size() == k){
            res.add(new ArrayList(track));
            return;
        }
        for(int i = start;i <= n - (k - track.size()) + 1;i++){
            // 做选择
            track.add(i);
            // 回溯
            backTrack(n,track,i + 1,k);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
~~~

#### 4级 例题：全排列

https://leetcode.cn/problems/permutations/description/

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

思路：

解法1：my83% 回溯算法

~~~java
class Solution {
    // 记录全排列的结果集
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        // 路径：已经做出的选择，遍历到底时的路径就是全排列的一个组成部分
        LinkedList<Integer> track = new LinkedList<>();
        // 「路径」中的元素会被标记为 true，避免重复使用
        boolean[] used = new boolean[nums.length];
        // 定义回溯函数，参数包含：选择列表、路径
        backtrack(nums,track,used);
        return res;
    }

    public void backtrack(int[] nums,LinkedList track,boolean[] used){
        // 满足条件时记录路径track到结果集中
        if(track.size() == nums.length){
            res.add(new LinkedList(track));
            return;
        }
        // 核心，遍历选择列表
        for(int i = 0;i < nums.length;i++){
            // 防止重复选取已经选择的元素，使选择列表一直减少
            if(used[i]){
                continue;
            }
            // 做选择,把选择记录到路径中，使路径一直增加
            track.addLast(nums[i]);
            used[i] = true;
            // 回溯
            backtrack(nums,track,used);
            // 撤销选择
            track.removeLast();
            used[i] = false;
        }
    }
}
~~~







### 2.2 形式二:元素可重不可复选

即 `nums` 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝，`backtrack` 核心代码如下：

```java
Arrays.sort(nums);
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 剪枝逻辑，跳过值相同的相邻树枝
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}


Arrays.sort(nums);
/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 剪枝逻辑，固定相同的元素在排列中的相对位置
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
```

### 2.3 形式三:元素无重可复选

即 `nums` 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可，`backtrack` 核心代码如下：

```java
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i);
        // 撤销选择
        track.removeLast();
    }
}


/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        backtrack(nums);
        // 撤销选择
        track.removeLast();
    }
}
```

