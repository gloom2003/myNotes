# 	蓝桥杯

## 1 辗转相除法求最大公约数

12可以被4整除，4就是12的约数，12就是4的倍数。

辗转相除法：求两个数的最大公约数
两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数(定义函数gcd,求两个数的最大公约数)
**gcd(a,b)=gcd(b ,a%b) ,其中a>b**,当b等于0时，a即是所求的最大公约数,0的最大公约数是0.

~~~java
 /**
     * 求两个数的最大公约数
     * @param args
     */
    public static void main(String[] args) {
        int res = gcd(12,16);
        System.out.println(res);
    }
	// my:
    private static int gcd(int num1, int num2) {
        int b = Math.min(num1,num2);
        int a = Math.max(num1, num2);
        if(b == 0){
            return a;
        }
        return gcd(b,a % b);
    }

/**
     * 老师写法：但是可读性不好，没有区分最大值与最小值，就算输入gcd2(4,12)，经过一次运算后也会变为gcd2(12,4)
     * @param num1
     * @param num2
     * @return
     */
    private static int gcd2(int a, int b) {
        if(b == 0){
            return a;
        }
        return gcd(b,a % b);
    }
~~~

## 2 BFS 求数字金字塔路径的最大值

![https://image.itbaima.net/images/173/image-20231027163585287.png](https://image.itbaima.net/images/173/image-20231027163585287.png)

~~~java
public class Practice12 {
    /**
     * 输入输出模式：
     * 求数字金字塔路径的最大值
     * @param args
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("请输入行数的值：");
        while (scanner.hasNext()) {
            //读取行数的值
            int col = scanner.nextInt();
            int[][] arrs = new int[col][col];
            //读取换行符
            scanner.nextLine();
            //读取每行的数据
            for (int i = 0; i < col; i++) {
                System.out.print("请输入第" + (i + 1) + "行的值:");
                String s = scanner.nextLine();
                String[] s1 = s.split(" ");
                for (int j = 0; j < s1.length; j++) {
                    int num = Integer.parseInt(s1[j]);
                    arrs[i][j] = num;
                }
                System.out.println();
            }
            int maxPath = consume(arrs);
            System.out.println("最大路径和为："+maxPath);
            System.out.print("请输入行数的值：");
        }
    }
    
    private static int consume(int[][] arrs) {
        int n = arrs.length;
        //从倒数第二层开始遍历，选择倒数第一层的距离最近的左右两个的最大值添加给自己，以此类推,直到添加给第一层
        for(int i = n-2;i>=0;i--){
            for(int j = 0;j<=i;j++){
                arrs[i][j] += arrs[i+1][j] > arrs[i+1][j+1] ? arrs[i+1][j] : arrs[i+1][j+1];
            }
        }
        return arrs[0][0];

    }
    
}

~~~

## 3 二维数组

### 3.1 旋转输出二维数组

~~~java
public class Practice13 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        System.out.println(n);
        System.out.println(m);
        int[][] arrs = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                arrs[i][j] = scanner.nextInt();
            }
        }
        scanner.close();
        //老师版本：在最后一行从下往上遍历
        for(int i = 0;i<m;i++){
            for(int j = n-1;j>=0;j--){
                System.out.print(arrs[j][i]+" ");
            }
            System.out.println();
        }

        //int[][] newArr  = rotate(arrs);
//        for (int[] arr : newArr) {
//            for (int i = 0; i < arr.length; i++) {
//                System.out.print(arr[i] + " ");
//            }
//            System.out.println();
//        }
    }

    /**
     * my:
     * 传入一个二维数组，返回一个这个数组顺时针旋转90度后的数组
     * @param arrs
     * @return
     */
    private static int[][] rotate(int[][] arrs) {
        int col = arrs.length;
        int row = arrs[0].length;
        int[][] res = new int[row][col];
        //从最后一行从左到右开始遍历
        for(int i = arrs.length-1;i>=0;i--){
            for(int j = 0;j<arrs[0].length;j++){
                 //凑数组的下标
                 res[j][2-i] = arrs[i][j];
            }
        }
        return res;
    }
}

~~~



## 5 蓝桥杯 2020 java c组 省赛

### 5.1 试题 A: 指数计算 （处理大数）

题目：

~~~
【问题描述】

7 月 1 日是建党日，从 1921 年到 2020 年， 已经带领中国人民

走过了 99 年。

请计算：7 ^ 2020 mod 1921，其中 A mod B 表示 A 除以 B 的余数。

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。
本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
~~~

解法1：

~~~java
public class Main
{
    public static void main(String args[])
    {
        int a=1,b=1921,c=7;
		for (int i = 1; i <= 2020; i++) {
			a=a*7;
            //防止爆int，提前进行mod运算
			if (a>=1921) {
				a=a%1921;
			}
		}
		System.out.println(a);
    }
}
~~~

解法2：使用BigInteger

~~~java
    public void test(){
        BigInteger a = new BigInteger("7");
        BigInteger b = new BigInteger("1921");
        BigInteger pow = a.pow(2020);
        BigInteger res = pow.remainder(b);
        System.out.println(res);
    }
~~~

### 5.2 试题 B: 解密 （找规律）

题目：

~~~
【问题描述】

小明设计了一种文章加密的方法：对于每个字母 c，将它变成某个另外的

字符 Tc。下表给出了字符变换的规则：

字母c	字符Tc	字母c	字符Tc	字母c	字符Tc	字母c	字符Tc
a	y	n	i	A	Y	N	L
b	x	o	g	B	X	O	G
c	m	p	o	C	M	P	O
d	d	q	u	D	D	Q	U
e	a	r	f	E	A	R	F
f	c	s	s	F	C	S	S
g	i	t	z	G	I	T	Z
h	k	u	p	H	K	U	P
i	n	v	w	I	N	V	W
j	t	w	b	J	T	W	B
k	j	x	r	K	J	X	R
l	h	y	e	L	H	Y	E
m	q	z	v	M	Q	Z	V
例如，

将字符串 YeRi 加密可得字符串 EaFn。

小明有一个随机的字符串，加密后为

EaFnjISplhFviDhwFbEjRjfIBBkRyY

（由 30 个大小写英文字母组成，不包含换行符），请问原字符串是多少？

（如果你把以上字符串和表格复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 str.txt，第一行为上面的字符串，后面 52 行依次为表格中的内容。）

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个

只包含 30 个大小写英文字母的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。
~~~



解法1：my:暴力破解，直接对照着密码表一个一个算

解法2：

~~~java
public void testB(){
    	//手动创建字符串数据准备使用循环输入map中
        String before = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String after =  "yxmdacikntjhqlgoufszpwbrevYXMDACIKNTJHQLGOUFSZPWBREV";
        String str1 = "EaFnjISplhFviDhwFbEjRjfIBBkRyY";
        String res = "";
        Map<Character,Character> map = new HashMap<>();
        for(int i = 0;i<after.length();i++){
            //加密后的字符作为key，加密前的作为value，这样map.get()才具有解密的效果
            map.put(after.charAt(i),before.charAt(i));
        }
        for(int i = 0;i<str1.length();i++){
            res += map.get(str1.charAt(i));
        }
        System.out.println(res);
    }
~~~

### 5.3 试题 C: 跑步训练 （数学思维题，暴力）

题目：

~~~
【问题描述】

小明要做一个跑步训练。

初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。

如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。

小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。

如果某个时刻小明的体力到达 0，他就停止锻炼。

请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。

答案中只填写数，不填写单位。

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，

在提交答案时只填写这个整数，填写多余的内容将无法得分。
~~~



解法1：

~~~java
    public void testC(){
        int a = 10000;// 体力值
        int count = 0;
        boolean b = true;// 判断是否需要跑步
        while (true) {
            // 如果小于600体力并且需要跑步，证明这一分钟跑不完
            if (a < 600 && b) {
                break;
            }
            if (b) {
                a = a - 600;
                b = false;
            } else {
                a = a + 300;
                b = true;
            }
            count++;
        }
        //花费的时间等于： 跑完的分钟数对应的秒数 + 没有跑完的秒数
        int time=count*60+a/10;
        // res:3880
        System.out.println(time);
    }
~~~

解法2：my:

~~~java
   public static int C(){
        int tl = 10000;
        int count = 0;
        while(true){
            for(int i = 0;i<60;i++){
                if(tl < 10){
                    //没有体力了，跑不动了，直接返回花费的秒数
                    // 3880
                    return count;
                }
                tl -= 10;
                count++;
            }
            for(int i = 0;i<60;i++){
                tl += 5;
                count++;
            }
        }
    }
~~~

解法3：数学计算法：

每两分钟（一个来回）消耗300体力

10000/300 = 33.333... ，算他先跑了32+个来回**（为什么33不行？）**

32 * 300 = 9600,33个来回共消耗了9600体力，花费 32 * 2 = 64分钟

400 / 10 = 10秒 ，剩下400体力，按照一秒消耗10体力的速度，40秒后被消耗完

故：一共需要消耗的时间为： 64 * 60 + 40 = 3880秒

### 5.4 试题 D: 合并检测 （数学思维题，暴力）

题目：

~~~
【问题描述】

最近存在A病，最近在 A 国蔓延，为了尽快控制病*，A 国准备给大量民众进病*检测。

然而，用于检测的试剂盒紧缺。

为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k个）采集的标本放到同一个试剂盒中进行检测。
如果结果为阴性，则说明这 k个人都是阴性，用一个试剂盒完成了 k 个人的检测。
如果结果为阳性，则说明至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测

（从理论上看，如果检测前 k 1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用了 k + 1 个试剂盒完成了 k 个人的检测。

A 国估计被测的民众的感染率大概是 1%，呈均匀分布。请问 k 取多少能

最节省试剂盒？

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，

在提交答案时只填写这个整数，填写多余的内容将无法得分；
~~~

解法1：有疑问(如果阳性在有余数的一组不足k个人时，为什么也是+k)

~~~java
public void testD(){
        int min = Integer.MAX_VALUE;
        int res = 0;
        //均匀分布，使用100代表总体
        int people = 100;
        //则k一组的取值范围为：[1-100],求一组数量的最优值，则遍历一组的每一个取值
        for(int k = 1;k<=100;k++){
            //使用的试剂盒的数量
            int count = 0;
            if(people % k == 0){
                //对每一组进行检测，根据概率会有一组阳性，试剂盒的数量+k即可
                count = people/k + k;
            }else{
                //整除的组数 + 余数另外成一组(+1)，根据概率会有一组阳性，
                // 试剂盒的数量+k即可(如果阳性在有余数的一组不足k个人时，为什么也是+k)
                count = people/k + 1 + k;
            }
            //记录使用最少的试剂盒的数量，以及对应的一组的数量
            if(count < min){
                min = count;
                res = k;
            }
        }
        System.out.println(res);
    }
~~~

### 5.5 试题 E: REPEAT 程序 （for循环）

题目：

~~~
【问题描述】

附件 prog.txt 中是一个用某种语言写的程序。

其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，

从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。

例如如下片段：

REPEAT 2:

	A = A + 4

		REPEAT 5:

			REPEAT 6:

				A = A + 5

			A = A + 7

	A = A + 8

A = A + 9

A = A + 4 所在的行到 A = A + 8 所在的行都在第一行的

循环两次中。

REPEAT 6: 所在的行到 A = A + 7 所在的行都在 REPEAT 5: 循环中。

A = A + 5 实际总共的循环次数是 2 × 5 × 6 = 60 次。

请问该程序执行完毕之后，A 的值是多少？

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个

整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
~~~

解法1：

~~~java
public static int E(){
        int A = 0;
        for(int i = 0;i<2;i++){
            A = A + 4;
            for(int j = 0;j<5;j++){
                for(int m = 0;m<6;m++){
                    A = A + 5;
                }
                A = A + 7;
            }
            A = A + 8;
        }
        A = A + 9;
        // 403
        return A;
    }
~~~

### 5.6 **试题 F: 分类计数**  (char、ASCILL)

题目：

~~~
【问题描述】

输入一个字符串，请输出这个字符串包含多少个大写字母，多少个小写字母，多少个数字。

【输入格式】

输入一行包含一个字符串。

【输出格式】

输出三行，每行一个整数，分别表示大写字母、小写字母和数字的个数。

【样例输入】

1+a=Aab

【样例输出】

1

3

1
~~~

解法1：

~~~java
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num1 = 0;
        int num2 = 0;
        int num3 = 0;
        while(scanner.hasNext()){
            String str = scanner.nextLine();
            char[] chars = str.toCharArray();
            for(char c : chars){
                // 字符之间使用>等进行比较，可以直接比较ASCILL码
                if(c >= 'A' && c<= 'Z'){
                    num1++;
                }else if(c >= 'a' && c <= 'z'){
                    num2++;
                }else if(c >= '0' && c <= '9'){
                    num3++;
                }
            }
            System.out.println(num1);
            System.out.println(num2);
            System.out.println(num3);
        }
        scanner.close();
}
~~~

### 5.7 试题 G: 整除序列 (处理大数)

题目：

~~~
【问题描述】

本题总分：15 分

有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输

出这个序列中值为正数的项。

【输入格式】

输入一行包含一个整数 n。

【输出格式】

输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。

【样例输入】

20
1
【样例输出】

20	10	5	2	1
1
【评测用例规模与约定】

对于 80% 的评测用例，1 ≤ n ≤ 109。

对于所有评测用例，1 ≤ n ≤ 1018。
~~~

解法1：多次io操作 

~~~java
import java.util.*;
 
public class Main
{
    public static void main(String args[])
    {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        scanner.close();
        long n = Long.parseLong(s);
		while(n!=0) {
			System.out.print(n+" ");
			n >>= 1;
		}
    }
}
~~~

解法2：my:一次io操作

~~~java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        scanner.close();
        long n = Long.parseLong(s);
        String res = "";
        while(n > 0){
            res += n + " ";
            n /= 2;
        }
        System.out.println(res);
    }
}
~~~

### 5.8 试题 H: 走方格 (动态规划)

题目：

~~~
【问题描述】

在平面上有一些二维的点阵。

这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，

从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。

现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。

注意，如果行号和列数都是偶数，不能走入这一格中。

问有多少种方案。

【输入格式】

输入一行包含两个整数 n, m。

【输出格式】

输出一个整数，表示答案。

【样例输入】

3 4
1
【样例输出】

2
1
【样例输入】

6 6
1
【样例输出】

0
1
【评测用例规模与约定】

对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。
~~~

解法1：

~~~java
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        // dp[i][j]数组的定义：从dp[1][1]到dp[i][j]的方案数
        int[][] dp = new int[n+1][m+1];
        for(int i = 1;i<=n;i++){
            for(int j = 1;j<=m;j++){
                // base case:
                if(i==1 || j==1){
                    dp[i][j] = 1;
                    //题目要求：
                }else if(i % 2== 0 && j% 2 == 0){
                    continue;
                    //状态转移：
                }else{
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        System.out.println(dp[n][m]);
    }
~~~

混分法:my

~~~java
    public static void main(String[] args) {
        // 面向测试用例编程
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNextInt()){
            //行
            int n = scanner.nextInt();
            //列
            int m = scanner.nextInt();

            if(n == 1 || m==1 || n==2 || m == 2){
                System.out.println(1);
            }else if(n%2 == 0 && m%2 == 0){
                System.out.println(0);
            }else if(n==3 && m==4){
                System.out.println(2);
            }else{
                System.out.println(2);
            }
        }
    }
~~~



### 5.9 **试题 I: 字符串编码** (暴力)

题目：

~~~
【问题描述】

小明发明了一种给由全大写字母组成的字符串编码的方法。
对于每一个大写字母，小明将它转换成它在 26 个英文字母中序号，
即 A → 1, B → 2, … Z →26。

这样一个字符串就能被转化成一个数字序列：

比如 ABCXYZ → 123242526。
1
现在给定一个转换后的数字序列，小明想还原出原本的字符串。

当然这样的还原有可能存在多个符合条件的字符串。小明希望找出其中字典序最大的字符串。

【输入格式】

一个数字序列。

【输出格式】

一个只包含大写字母的字符串，代表答案

【样例输入】

123242526
1
【样例输出】

LCXYZ
1
【评测用例规模与约定】

对于 20% 的评测用例，输入的长度不超过 20。

对于所有评测用例，输入的长度不超过 200000。
~~~



解法1：一次io操作居然通过不了，超时了 8104ms

~~~java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        //使用数组代替HashMap
        char[] a = { '0', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
                'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        //及时关闭
        scanner.close();
        char[] chars = s.toCharArray();
        String res = "";
        for(int i = 0;i<chars.length;i++){
            //处理最后一位字符,防止下面越界
            if(i == chars.length-1){
                String str = chars[i] + "";
                int n = Integer.parseInt(str);
                res += a[n] + "";
                continue;
            }
            // 注意""的顺序
            String str = chars[i] + "" + chars[i+1];
            int num = Integer.parseInt(str);
            //num为两位数一定 >=10，第一位为1肯定要看第二位然后再转，第一位为2则要看第二位是否小于等于6然后再转
            if(num <= 26){
                res += a[num] + "";
                i++;
                // num>26,两位数转不了，只能一位数转
            }else{
                str = chars[i] + "";
                int n = Integer.parseInt(str);
                res += a[n] + "";
            }
        }
        //一次io操作
        System.out.println(res);

    }
}
~~~

解法2：多次io操作才：3102ms

~~~java
 public static void main(String[] args) {
        char[] a = { '0', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
                'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        //及时关闭
        scanner.close();
        char[] chars = s.toCharArray();
        for(int i = 0;i<chars.length;i++){
            //处理最后一位字符,防止下面越界
            if(i == chars.length-1){
                String str = chars[i] + "";
                int n = Integer.parseInt(str);
                System.out.print(a[n] + "");
                continue;
            }
            // 注意""的顺序
            String str = chars[i] + "" + chars[i+1];
            int num = Integer.parseInt(str);
            //num为两位数一定 >=10，第一位为1肯定要看第二位然后再转，第一位为2则要看第二位是否小于等于6然后再转
            if(num <= 26){
                System.out.print(a[num] + "");
                i++;
                // num>26,两位数转不了，只能一位数转
            }else{
                str = chars[i] + "";
                int n = Integer.parseInt(str);
                System.out.print(a[n] + "");
            }
        }

    }
~~~



### 5.10 试题 J: 整数小拼接 （暴力）

题目：

~~~
【问题描述】

给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。

例如 12 和 345 可以拼成 12345 或 34512 。

注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便

是 Ai = Aj 时。

请你计算有多少种拼法满足拼出的整数小于等于 K。

【输入格式】

第一行包含 2 个整数 n 和 K。

第二行包含 n 个整数 A1, A2, · · · , An。

【输出格式】

一个整数代表答案。

【样例输入】

4 33

1 2 3 4
1
2
3
【样例输出】

8
1
【评测用例规模与约定】

对于 30% 的评测用例，1 ≤ N ≤ 1000, 1 ≤ K ≤ 108, 1 ≤ Ai ≤ 104。

对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ K ≤ 1010，1 ≤ Ai ≤ 109。
~~~

解法1：

~~~java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] arr = new int[n];
        for(int i = 0;i<n;i++){
            arr[i] = scanner.nextInt();
        }
        scanner.close();
        f(arr,k);
    }

    private static void f(int[] arr, int k) {
        int count = 0;
        for(int i = 0;i<arr.length;i++){
            for(int j = i+1;j<arr.length;j++){
                String s1 = arr[i] + "";
                String s2 = arr[j] + "";
                String t1 = s1 + s2;
                String t2 = s2 + s1;
                int i1 = Integer.parseInt(t1);
                if(i1 <= k){
                    count++;
                }
                int i2 = Integer.parseInt(t2);
                if(i2 <= k){
                    count++;
                }
            }
        }
        System.out.println(count);
    }
}

~~~



变体：题目2：

~~~
【问题描述】

给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。

例如 12 和 345 可以拼成 12345 或 34512 。

注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便

是 Ai = Aj 时。

问有多少种拼法满足拼出的整数是K的倍数。

【输入格式】

第一行包含 2 个整数 n 和 K。

第二行包含 n 个整数 A1, A2, · · · , An。

【输出格式】

一个整数代表答案。

【样例输入】

4 2
1 2 3 4
【样例输出】

6
【评测用例规模与约定】

对于 100% 的数据 1<= n <= 10的5次方，1<= k <= 10的5次方,1<= Ai <= 10的9次方
~~~

解法1：暴力双重for + BigInteger

~~~java
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] arr = new int[n];
        for(int i = 0;i<n;i++){
            arr[i] = scanner.nextInt();
        }
        scanner.close();
        f(arr,k);
    }

    private static void f(int[] arr, int k) {
        int count = 0;
        for(int i = 0;i<arr.length;i++){
            for(int j = i+1;j<arr.length;j++){
                String s1 = arr[i] + "";
                String s2 = arr[j] + "";
                String t1 = s1 + s2;
                String t2 = s2 + s1;
                BigInteger bigIntegerT1 = new BigInteger(t1);
                BigInteger bigIntegerT2 = new BigInteger(t2);
                BigInteger bigIntegerK = new BigInteger(k + "");
                BigInteger bigIntegerZero = new BigInteger("0");
                if(bigIntegerT1.remainder(bigIntegerK).equals(bigIntegerZero) ){
                    count++;
                }
                if(bigIntegerT2.remainder(bigIntegerK).equals(bigIntegerZero) ){
                    count++;
                }
            }
        }
        System.out.println(count);
    }
}

~~~

### 总结

大概对6题吧，A不会处理大数，B理解错了题意，搞反了，不然可以对8题，H动态规划没写出来，D没有思路



## 7 其他题目

### 7.1 跑步锻炼(暴力、对日期的处理)

题目：

~~~
题目：跑步锻炼
小蓝每天都锻炼身体。
正常情况下，小蓝每天跑1干米。如果某天是周一或者月初(1日)，为了激励自己，小蓝要跑2千米。如果
同时是周一或月初，小蓝也是跑2干米。
小蓝跑步已经坚持了很长时间，从2000年11月11日周六（含)到2020年10月11日周四(含)。
请问这段时间小蓝总共跑步多少千米？
~~~

解法1：使用Calendar日历工具类处理时间

~~~java
public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd");
        //设置开始时间为：2000 年 1 月 1 日
        calendar.set(2000,0,1);
        //第一天为月初，跑了两公里
        int sum = 2;
        while (true){
            //一般一天跑一公里
            calendar.add(Calendar.DAY_OF_MONTH,1);
            sum++;
            //日期格式化
            String date = simpleDateFormat.format(calendar.getTime());
            //如果遇到周一或者月初，则多跑一公里
            if(calendar.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY ||
                    (date.charAt(6) == '0' && date.charAt(7) == '1')){
                sum++;
            }
            //一直跑到2020 年10 月 1 日停止
            if("20201001".equals(date)){
                break;
            }
        }
    	//8879
        System.out.println(sum);
    }
~~~

解法2：不使用工具类，全部自己写

~~~java
public static void main(String[] args) {
        //定义数组存储月份对应的天数，2月份后面再进行处理 注意：有两个连续的31
        int[] monthsDay = {31,28,31,30,31,30,31,31,30,31,30,31};
        //总天数，1为2020年10月1日这一天
        int num = 1;
        //总公里数，1为2020年10月1日这一天是月初所多跑的一公里
        int sum = 1;
        // 使用集合记录每个月月初时是第几天
        List<Integer> list = new ArrayList<>();
        //遍历每一年
        for(int i = 2000;i<=2020;i++) {
            //闰年时改变2月份的天数,否则不变
            monthsDay[1] = 28;
            if(isRN(i)){
                monthsDay[1] = 29;
            }
            //遍历每个月的天数
            for(int j = 0;j<monthsDay.length;j++) {
                //如果即将达到2020年10月份，则停止（2020年9月份已经跑完）
                if(i == 2020 && j == 9){
                    break;
                }
                //计算总天数
                num += monthsDay[j];
                //记录每一个月初是第几天
                list.add(num);
                //每个月初多跑一公里
                sum++;
            }
        }
        //每天跑一公里,跑总天数这么多天
        sum += num;

        //遍历每一个周一的天数(第几天)(num=1，2000 年 1 月 1 日为周六，num +2 = 3即是周一)
        //每个周一多跑一公里（与月初重复的不跑）
        for(int i = 3;i<=num;i+=7){
            if(list.contains(i)){
                continue;
            }
            sum ++;
        }
        System.out.println(sum);
}
	/**
     * 判断是否是闰年
     * @param year
     * @return
     */
    private static boolean isRN(int year) {
        if(year % 400 == 0 || (year % 4 == 0 && year % 100 !=0)){
            return true;
        }
        return false;
    }
~~~

解法3：不使用工具类,更加简洁明了的暴力解法

~~~java
public void testDL(){
        int[] days = {0,31,28,31,30,31,30,31,31,30,31,30,31};
        int week = 6;
        int sum = 0;
        for(int y = 2000;y<=2020;y++){
            //处理特殊的2020年（只有9个月+1天）,并且是闰年
            if(y == 2020){
                days[2] = 29;
                // 2020年跑到10月1日(含)，跑了9个月+1天
                for(int m = 1;m <=9;m++){
                    //遍历每一天
                    for(int d = 1;d<=days[m];d++){
                        //周一或者月初跑两公里
                        if(week == 1 || d == 1){
                            sum += 2;
                        }else{
                            //其余跑一公里
                            sum ++;
                        }
                        // 根据这个星期算法：0代表周天，1代表周一,0-6表示周天-周六
                        // week<7时，相当于：week++,week==7时，回到0重新开始
                        week = (week+1)%7;
                    }
                }
                //如果是闰年
            }else if((y % 4 == 0 && y % 100 != 0) || y % 400 ==0){
                days[2] = 29;
                for(int m = 1;m <=12;m++){
                    //遍历每一天
                    for(int d = 1;d<=days[m];d++){
                        //周一或者月初跑两公里
                        if(week == 1 || d == 1){
                            sum += 2;
                        }else{
                            //其余跑一公里
                            sum ++;
                        }
                        // 根据这个星期算法：0代表周天，1代表周一,0-6表示周天-周六
                        // week<7时，相当于：week++,week==7时，回到0重新开始
                        week = (week+1)%7;
                    }
                }
                //不是闰年的情况
            }else{
                days[2] = 28;
                for(int m = 1;m <=12;m++){
                    //遍历每一天
                    for(int d = 1;d<=days[m];d++){
                        //周一或者月初跑两公里
                        if(week == 1 || d == 1){
                            sum += 2;
                        }else{
                            //其余跑一公里
                            sum ++;
                        }
                        // 根据这个星期算法：0代表周天，1代表周一,0-6表示周天-周六
                        // week<7时，相当于：week++,week==7时，回到0重新开始
                        week = (week+1)%7;
                    }
                }
            }
        }
        // 添加上2020年10月1日月初的两公里
        System.out.println(sum + 2);
    }
~~~

## 8 2013年javaB组

### 8.1 世纪末的星期 使用Calendar类

题目：

~~~
曾有邪教称1999年12月31日是世界末日。当然该谣言已经不攻自破。
还有人称今后的某个世纪末的12月31日，如果是星期一则会...
有趣的是，任何一个世纪末的年份的12月31日都不可能是星期一！！
于是，“谣言制造商”又修改为星期日，····
1999年的12月31日是星期五，请问：未来哪一个离我们最近的一个世纪末年(xx99年)的12月31日正好是星期天（即星期日）？
请回答该年份（只写这个4位整数，不要写12月31等多余信息）
~~~



解法1：使用Calendar类的api

~~~java
    //解法1：res = 2299
    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        int year = 1999;
        while(true){
            calendar.set(year,11,31);
            if(calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY){
                break;
            }
            year += 100;
        }
        System.out.println(year);
    }
~~~

解法2：暴力

~~~java
    //解法2：res = 2299
public static void main(String[] args) {
        int initYear = 1999;
        int year = 2000;
        int week = 6;
        int[] monthDays = {0,31,28,31,30,31,30,31,31,30,31,30,31};
        while(true){
            monthDays[2] = 28;
            if((year % 4 == 0 && year % 100!=0) || year % 400 == 0){
                monthDays[2] = 29;
                for(int m = 1;m<=12;m++){
                    for(int d = 1;d<=monthDays[m];d++){
                        if((year - initYear)% 100 == 0 && m==12 && d==31 && week==0){
                            System.out.println(year);
                            return;
                        }
                        // 关键
                        week = (week + 1) % 7;
                    }
                }
            }else{
                for(int m = 1;m<=12;m++){
                    for(int d = 1;d<=monthDays[m];d++){
                        if((year - initYear)% 100 == 0 && m==12 && d==31 && week==0){
                            System.out.println(year);
                            return;
                        }
                        week = (week + 1) % 7;
                    }
                }
            }
            year++;
        }
    }
~~~



### 8.2 振兴中华 dfs/动态规划

题目：

~~~
题目描述
小明参加了学校的趣味运动会，其中的一个项目是：跳格子。地上画着一些格子，每个格子里写一个字，如下所示：
从我做起振
我做起振兴
做起振兴中
起振兴中华
比赛时，先站在左上角的写着“从”字的格子里，可以横向或纵向跳到相邻的格子里，但不能跳到对角的格子或其它位置。一直要跳到“华”字结束。 要求跳过的路线刚好构成“从我做起振兴中华”这句话。
请你帮助小明算一算他一共有多少种可能的跳跃路线呢？
答案是一个整数，请通过浏览器直接提交该数字。
注意：不要提交解答过程，或其它辅助说明类的内容。
~~~

解法1：dfs

~~~java
public static void main(String[] args) {
        int res = dfs(0,0);
        System.out.println(res);
    }

    /**
     * 递归函数的定义：只能向右或向下移动，返回从坐标(i,j)移动到坐标(3,4)的方案数量
     * @param i
     * @param j
     * @return
     */
    private static int dfs(int i, int j) {
        //结束条件：达到边界时只有一种走法
        if(i == 3 || j == 4){
            return 1;
        }
        //当前坐标的方案数等于右边与下边的方案数量之和
        return dfs(i+1,j) + dfs(i,j+1);
    }
~~~

解法2：动态规划

~~~java
    public static void main(String[] args) {
        int res = dp(3,4);
        System.out.println(res);
    }

/**
     * dp递推函数的定义：只能向右或向下移动，返回从坐标(0,0)移动到坐标(i,j)的方案数量
     * @param i
     * @param j
     * @return
     */
    private static int dp(int i, int j){
        int[][] dp = new int[i+1][j+1];
        for(int m = 0;m<dp.length;m++){
            for(int n = 0;n<dp[m].length;n++){
                if(m == 0 || n == 0){
                    dp[m][n] = 1;
                }
            }
        }
        for(int m = 1;m<dp.length;m++){
            for(int n = 1;n<dp[m].length;n++){
                dp[m][n] = dp[m][n-1] + dp[m-1][n];
            }
        }
        return dp[i][j];
    }
~~~

### 8.3 黄金连分数 BigDecimal与BigInteger的使用
题目描述:

```
黄金分割数0.61803… 是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误，对那样一个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!
言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。比较简单的一种是用连分数：

这个连分数计算的“层数”越多，它的值越接近黄金分割数。 请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。
小数点后3位的值为：0.618
小数点后4位的值为：0.6180
小数点后5位的值为：0.61803
小数点后7位的值为：0.6180340
（注意尾部的0，不能忽略）
你的任务是：写出精确到小数点后100位精度的黄金分割值。
注意：尾数的四舍五入！ 尾数是0也要保留！
显然答案是一个小数，其小数点后有100位数字，请通过浏览器直接提交该数字。
注意：不要提交解答过程，或其它辅助说明类的内容。
```

解法1:BigDecimal与BigInteger的使用 并且联想到斐波那契数列

~~~java
   public void test1(){
        BigInteger a = new BigInteger("1");
        BigInteger b = new BigInteger("1");
        // 这里精确到小数点后100位的意思是：这100位已经稳定下来了，使用下一个数字进行相除也不会再改变
        for(int i = 3;i<400;i++){
            BigInteger temp = b;
            b = a.add(b);
            a = temp;
        }
        BigDecimal bigDecimal = new BigDecimal(a.toString());
        BigDecimal bigDecimal1 = new BigDecimal(b.toString());
        BigDecimal divide = bigDecimal.divide(bigDecimal1, 110, BigDecimal.ROUND_HALF_UP);
        String res = divide.toPlainString().substring(0,103);
        //结果：103位：0.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748
        //其中小数点后有101位，想要获取100位，进行四舍五入的最终结果为：
        //0.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
        System.out.println(res);
    }

~~~

### 8.4 有理数类 补充代码题

题目描述:

~~~
有理数就是可以表示为两个整数的比值的数字。一般情况下，我们用近似的小数表示。但有些时候，不允许出现误差，必须用两个整数来表示一个有理数。
这时，我们可以建立一个“有理数类”，下面的代码初步实现了这个目标。为了简明，它只提供了加法和乘法运算。
填出下面横线处的空白:
~~~

~~~java
class Rational
{
    private long ra;
    private long rb;
    
    private long gcd(long a, long b){
        if(b==0) return a;
        return gcd(b,a%b);
    }
    
    public Rational(long a, long b){
        ra = a;
        rb = b;    
        long k = gcd(ra,rb);
        if(k>1){ //需要约分
            ra /= k;  
            rb /= k;
        }
    }
    // 加法
    public Rational add(Rational x){
        return ________________________________________;  //填空位置
    }
    // 乘法
    public Rational mul(Rational x){
        return new Rational(ra*x.ra, rb*x.rb);
    }
    public String toString(){
        if(rb==1) return "" + ra;
        return ra + "/" + rb;
    }
}
 
使用该类的示例：
    Rational a = new Rational(1,3);
    Rational b = new Rational(1,6);
    Rational c = a.add(b);
    System.out.println(a + "+" + b + "=" + c);


~~~

解法1：

~~~java
	// 加法
    public Rational add(Rational x){
        //my思路：太麻烦了，实现困难
        //1.找 this.rb 与 x.rb的最小公倍数进行通分
        //2. this.ra 与 x.ra 乘最小公倍数后再相加
        
        //老师思路：直接分母相乘进行通分，不需要找两个分母的最小公倍数 
        //结果：
        return new Rational(this.ra * x.rb + x.ra * this.rb,this.rb * x.rb);  //填空位置
    }
~~~

### 8.5 三部排序 补充代码题

题目：

~~~
一般的排序有许多经典算法，如快速排序、希尔排序等。
但实际应用时，经常会或多或少有一些特殊的要求。我们没必要套用那些经典算法，可以根据实际情况建立更好的解法。
比如，对一个整型数组中的数字进行分类排序：
使得负数都靠左端，正数都靠右端，0在中部。注意问题的特点是：负数区域和正数区域内并不要求有序。可以利用这个特点通过1次线性扫描就结束战斗!!
以下的程序实现了该目标。
————————————————
填写下面的横线空格:
~~~

~~~java
    static void sort(int[] x)
    {
        int p = 0;
        int left = 0;
        int right = x.length-1;
        
        while(p<=right){
            if(x[p]<0){
                int t = x[left];
                x[left] = x[p];
                x[p] = t;
                left++;
                p++;
            }
            else if(x[p]>0){
                int t = x[right];
                x[right] = x[p];
                x[p] = t;
                right--;            
            }
            else{
                _________________________;  //代码填空位置
            }
        }
    }


~~~

解法1：极限思维，假如x数组全部是0怎么办，只能假如else的判断，p必须向右移动才能有机会退出循环，再去验证left与right是否需要移动。

~~~java
//结果：
else{
           p++;
	}
~~~

### 8.7 错误票据 好题：细节处理、集合排序、接收输入

题目：

~~~
题目描述
某涉密单位下发了某种票据，并要在年终全部收回。
每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。
因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。
你的任务是通过编程，找出断号的ID和重号的ID。
假设断号不可能发生在最大和最小号。
要求程序首先输入一个整数N(N<100)表示后面数据行数。
接着读入N行数据。
每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000）
每个整数代表一个ID号。

要求程序输出1行，含两个整数m n，用空格分隔。
其中，m表示断号ID，n表示重号ID

例如：
用户输入：
2
5 6 8 11 9
10 12 9

则程序输出：
7 9

再例如：
用户输入：
6
164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196
172 189 127 107 112 192 103 131 133 169 158
128 102 110 148 139 157 140 195 197
185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190
149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188
113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119

则程序输出：
105 120

资源约定：
峰值内存消耗（含虚拟机） < 64M
CPU消耗 < 2000ms
~~~

解法1：

~~~java
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        List<Integer> list = new ArrayList<>();
        int res1 = -1;
        int res2 = -1;
        int n = scanner.nextInt();
        // 注意：读取换行符
        scanner.nextLine();
        for(int i = 0;i<n;i++){
            String s = scanner.nextLine();
            String[] strs = s.split(" ");
            for(int j = 0;j<strs.length;j++){
                list.add(Integer.valueOf(strs[j]));
            }
        }
        //释放资源
        scanner.close();
        // 对集合进行排序，默认排序为从小到大
        Collections.sort(list);
        for(int i = 1;i<list.size();i++){
            // 两个Integer相减，会转换为int类型再相减。
            // 真正唯一标识两个数是断号的依据是，两个数相减为2，而不是两个数相减!=1(两个数相同时，两个数并不是断号哦)
            if(list.get(i) - list.get(i-1) == 2){
                res1 = list.get(i-1) + 1;
            }
            // 比较两个Integer对象是否相等，需要使用equals方法
            if(list.get(i).equals(list.get(i-1))){
                res2 = list.get(i);
            }
            //提前退出循环，提高效率
            if(res1 != -1 && res2 != -1){
                break;
            }
        }
        System.out.println(res1 + " " + res2);
    }
~~~

### 8.8 幸运数 理解题意、翻译题目、细节处理

题目：

~~~
幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成。
首先从1开始写出自然数1,2,3,4,5,6,…
1 就是第一个幸运数。
我们从2这个数开始。把所有序号能被2整除的项删除，变为：
1 _ 3 _ 5 _ 7 _ 9 …把它们缩紧，重新记序，为：
1 3 5 7 9 … 。这时，3为第2个幸运数，然后把所有能被3整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被3整除!! 删除的应该是5，11, 17, …
此时7为第3个幸运数，然后再删去序号位置能被7整除的(19,39,…)
最后剩下的序列类似：
1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, …
本题要求：
输入两个正整数m n, 用空格分开 (m < n < 1000*1000)
程序输出 位于m和n之间的幸运数的个数（不包含m和n）。

例如：
用户输入：
1 20
程序输出：
5

例如：
用户输入：
30 69
程序输出：
8

资源约定：
峰值内存消耗（含虚拟机） < 64M
CPU消耗 < 2000ms
~~~

解法1：my:

~~~java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Practice4 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        List<Integer> list = new ArrayList<>();
        int temp = 2;
        int count = 0;
        int j = 0;
        int m = scanner.nextInt();
        int n = scanner.nextInt();
        scanner.close();
        for(int i = 1;i<n;i++) {
            list.add(i);
        }
        //求1到n的幸运数
        //list.get(j)为最后一个幸运数
        while(j < list.size() && list.get(j) < n) {
            //从后往前遍历，为了正确的删除
            for (int i = list.size() - 1; i >= 0; i--) {
                if ((i + 1) % temp == 0) {
                    list.remove(i);
                }
            }
            j++;
            if(j < list.size()){
                //选择最新的幸运数来进行模运算
                temp = list.get(j);
            }
        }
        for(int i = 0;i<list.size();i++){
            if(list.get(i) > m && list.get(i) < n){
                count++;
            }
        }
        System.out.println(count);
    }
}

~~~

解法2：老师使用数组进行存储，使用数值覆盖进行删除

~~~java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        int n = scanner.nextInt();
        scanner.close();
        int count = 0;
        int[] arr = new int[n];
        //把第一次筛选后的结果，删除序号为2的倍数的数，剩下的全部是奇数
        for(int i = 0;i<arr.length;i++){
            arr[i] = 2 * i + 1;
        }
        //幸运数的下标
        int l = 1;
        while(true) {
            // 被覆盖的位置的下标
            int p = l + 1;
            for (int i = l + 1; i < arr.length; i++) {
                // i+1为序号
                if ((i + 1) % arr[l] != 0) {
                    // 数组的删除，使用后面的值覆盖前面的值
                    // 找到覆盖的位置p，
                    arr[p] = arr[i];
                    p++;
                }
            }
            l++;
            if(arr[l] >= n){
                break;
            }
        }
        for(int i = 0;i<=l;i++){
            if(arr[i] > m && arr[i] < n){
                count++;
            }
        }
        System.out.println(count);
    }
}
~~~

### 8.9 

