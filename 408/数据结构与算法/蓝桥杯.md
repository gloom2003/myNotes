# 蓝桥杯

## 1 辗转相除法求最大公约数

12可以被4整除，4就是12的约数，12就是4的倍数。

辗转相除法：求两个数的最大公约数
两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数(定义函数gcd,求两个数的最大公约数)
gcd(a,b)=gcd(b ,a%b) ,其中a>b,当b等于0时，a即是所求的最大公约数,0的最大公约数是0.

~~~java
 /**
     * 求两个数的最大公约数
     * @param args
     */
    public static void main(String[] args) {
        int res = gcd(12,16);
        System.out.println(res);
    }

    private static int gcd(int num1, int num2) {
        int min = Math.min(num1,num2);
        int max = Math.max(num1, num2);
        if(min == 0){
            return max;
        }
        return gcd(min,max % min);
    }

/**
     * 老师写法：但是可读性不好，没有区分最大值与最小值，就算输入gcd2(4,12)，经过一次运算后也会变为gcd2(12,4)
     * @param num1
     * @param num2
     * @return
     */
    private static int gcd2(int num1, int num2) {
        if(num2 == 0){
            return num1;
        }
        int modRes = num1 % num2;
        return gcd(num2,modRes);
    }
~~~

## 2 BFS 求数字金字塔路径的最大值

![https://image.itbaima.net/images/173/image-20231027163585287.png](https://image.itbaima.net/images/173/image-20231027163585287.png)

~~~java
public class Practice12 {
    /**
     * 输入输出模式：
     * 求数字金字塔路径的最大值
     * @param args
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("请输入行数的值：");
        while (scanner.hasNext()) {
            //读取行数的值
            int col = scanner.nextInt();
            int[][] arrs = new int[col][col];
            //读取换行符
            scanner.nextLine();
            //读取每行的数据
            for (int i = 0; i < col; i++) {
                System.out.print("请输入第" + (i + 1) + "行的值:");
                String s = scanner.nextLine();
                String[] s1 = s.split(" ");
                for (int j = 0; j < s1.length; j++) {
                    int num = Integer.parseInt(s1[j]);
                    arrs[i][j] = num;
                }
                System.out.println();
            }
            int maxPath = consume(arrs);
            System.out.println("最大路径和为："+maxPath);
            System.out.print("请输入行数的值：");
        }
    }
    
    private static int consume(int[][] arrs) {
        int n = arrs.length;
        //从倒数第二层开始遍历，选择倒数第一层的距离最近的左右两个的最大值添加给自己，以此类推,直到添加给第一层
        for(int i = n-2;i>=0;i--){
            for(int j = 0;j<=i;j++){
                arrs[i][j] += arrs[i+1][j] > arrs[i+1][j+1] ? arrs[i+1][j] : arrs[i+1][j+1];
            }
        }
        return arrs[0][0];

    }
    
}

~~~

## 3 二维数组

### 3.1 旋转输出二维数组

~~~java
public class Practice13 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        System.out.println(n);
        System.out.println(m);
        int[][] arrs = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                arrs[i][j] = scanner.nextInt();
            }
        }
        scanner.close();
        //老师版本：在最后一行从下往上遍历
        for(int i = 0;i<m;i++){
            for(int j = n-1;j>=0;j--){
                System.out.print(arrs[j][i]+" ");
            }
            System.out.println();
        }

        //int[][] newArr  = rotate(arrs);
//        for (int[] arr : newArr) {
//            for (int i = 0; i < arr.length; i++) {
//                System.out.print(arr[i] + " ");
//            }
//            System.out.println();
//        }
    }

    /**
     * my:
     * 传入一个二维数组，返回一个这个数组顺时针旋转90度后的数组
     * @param arrs
     * @return
     */
    private static int[][] rotate(int[][] arrs) {
        int col = arrs.length;
        int row = arrs[0].length;
        int[][] res = new int[row][col];
        //从最后一行从左到右开始遍历
        for(int i = arrs.length-1;i>=0;i--){
            for(int j = 0;j<arrs[0].length;j++){
                 //凑数组的下标
                 res[j][2-i] = arrs[i][j];
            }
        }
        return res;
    }
}

~~~

## 4 BigInteger的使用

理论上能够表示无线大的数，只要计算机内存足够大。

### 4.1 BigInteger 的基本运算

- 加：a.add(b)
- 减：a.subtrac(b)
- 乘: a.multiply(b)
- 除: a.divide(b)
- mod: BigInteger c = b.remainder(a)
- 绝对值：a.abs()
- n次幂：a.pow(n)
- 取反数：a.negate()
- 最大公约数：a.gcd(b)
- 比较：a.equals(b) 返回boolean、a.compareTo(b) 返回数字(0,正数，负数)
- 转换类型：BigInteger.valueOf()





valueOf(parament); 将参数转换为调用者的类型, 比如 :

```java
int a=3;
BigInteger b=BigInteger.valueOf(a)
```

BigInteger 之间的比较

```java
BigInteger a = new BigInteger("123");
BigInteger b = new BigInteger("456");

System.out.println(a.equals(b)); // a == b 时为 true 否则为 false
BigInteger a = new BigInteger("123");
BigInteger b = new BigInteger("456");

if(a.compareTo(b) == 0) System.out.println("a == b"); // a == b
else if(a.compareTo(b) > 0) System.out.println("a > b"); // a > b
else if(a.compareTo(b) < 0) System.out.println("a < b"); // a < b
```

加法

```
BigInteger a = new BigInteger("123");
BigInteger b = new BigInteger("456");

a.add(b);
```

减法

```
BigInteger a = new BigInteger("123");
BigInteger b = new BigInteger("456");

a.subtract(b);
```

乘法

```
BigInteger a = new BigInteger("123");
BigInteger b = new BigInteger("456");

a.multiply(b);
```

除法

```
BigInteger a = new BigInteger("123");
BigInteger b = new BigInteger("456");

a.divide(b);
```

取余

```
BigInteger a = new BigInteger("123");
BigInteger b = new BigInteger("456");

BigInteger c = b.remainder(a);
System.out.println(c);
```

除法取余

```
BigInteger a = new BigInteger("123");
BigInteger b = new BigInteger("456");

BigInteger result[] = b.divideAndRemainder(a); // 该函数返回的是数组
System.out.println("商是：" + result[0] + "；余数是：" + result[1]);
```

最大公约数

```
BigInteger a = new BigInteger("12");
BigInteger b = new BigInteger("56");
        
System.out.println(a.gcd(b)); // 4
```

绝对值

```
BigInteger a = new BigInteger("-12");
        
System.out.println(a.abs()); // 12
```

取反数

```
BigInteger a = new BigInteger("-12");
        
System.out.println(a.negate()); // 12
```

幂

```
BigInteger a = new BigInteger("2");
        
System.out.println(a.pow(3)); // 8
```

## Calendar 日期类的使用

获取`Calendar`实例的代码如下所示：

```java
Calendar calendar = Calendar.getInstance();
```

### 获取当前时间

```java
package com.zwwhnly.springbootaction.date;

import java.util.Calendar;

public class CalendarDemo {
    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();

        int year = calendar.get(Calendar.YEAR);
        // 月份的下标是从0开始的，即0~11分别代表1~12月，因此需要+1
        int month = calendar.get(Calendar.MONTH) + 1;
        int day = calendar.get(Calendar.DAY_OF_MONTH);
        // 24小时制
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        int minute = calendar.get(Calendar.MINUTE);
        int second = calendar.get(Calendar.SECOND);

        System.out.println("现在是：" + year + "年" + month + "月" + day + "日" + hour + "时" + minute + "分" + second + "秒");
    }
}
```

运行结果：

> 现在是：2019年2月21日15时36分38秒

**注意事项：**月份的下标是从0开始的，即0到11分别代表1到12月。

### 设置时间

假设我们现在需要将时间设置为2019-02-21 23:59:59。

####  一起设置

```java
Calendar calendar = Calendar.getInstance();
//1:将时间设置为2019-02-21 23:59:59。
calendar.set(2019, Calendar.FEBRUARY, 21, 23, 59, 59);
//2:将时间设置为2019-01-31
calendar.set(2019, Calendar.JANUARY, 31);
System.out.println(calendar.getTime());
```

#### 分别设置

```java
Calendar calendar = Calendar.getInstance();
calendar.set(Calendar.YEAR, 2019);
calendar.set(Calendar.MONTH, Calendar.FEBRUARY);
calendar.set(Calendar.DAY_OF_MONTH, 21);
calendar.set(Calendar.HOUR_OF_DAY, 23);
calendar.set(Calendar.MINUTE, 59);
calendar.set(Calendar.SECOND, 59);

System.out.println(calendar.getTime());
```

3.1和3.2的运行结果都如下所示：

> Thu Feb 21 23:59:59 CST 2019

###  时间计算

#### 增加秒

我们在3.1的基础上增加1秒，那么时间应该是2019-02-22 00:00:00。

```java
Calendar calendar = Calendar.getInstance();
calendar.set(2019, Calendar.FEBRUARY, 21, 23, 59, 59);
calendar.add(Calendar.SECOND, 1);
System.out.println(calendar.getTime());
```

运行结果：

> Fri Feb 22 00:00:00 CST 2019

#### 增加月

首先我们将时间设置为2019-01-31，然后先增加1个月，再增加2个月，代码如下所示：

```java
Calendar calendar = Calendar.getInstance();

calendar.set(2019, Calendar.JANUARY, 31);
System.out.println(calendar.getTime());
calendar.add(Calendar.MONTH, 1);
System.out.println(calendar.getTime());
calendar.add(Calendar.MONTH, 2);
System.out.println(calendar.getTime());
```

运行结果：

> Thu Jan 31 15:58:03 CST 2019
> **Thu Feb 28 15:58:03 CST 2019**
> Sun Apr 28 15:58:03 CST 2019

**注意事项：当所在的月份没有那个日期时，如2月份没有31号，返回的是所在月的最后一天(2月28号)。**

###  获取某月的第一天和最后一天

```java
package com.zwwhnly.springbootaction.date;

import java.text.SimpleDateFormat;
import java.util.Calendar;

public class CalendarDemo {
    public static void main(String[] args) {
        System.out.println(getFirstDayOfMonth(2019, 2));
        System.out.println(getLastDayOfMonth(2019, 2));

        System.out.println(getFirstDayOfMonth(2019, 3));
        System.out.println(getLastDayOfMonth(2019, 3));
    }

    public static String getLastDayOfMonth(int year, int month) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        // 关键：获取当前月份的最后一天：calendar.getActualMaximum(Calendar.DATE)
        calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DATE));

        return new SimpleDateFormat("yyyy-MM-dd").format(calendar.getTime());
    }

    public static String getFirstDayOfMonth(int year, int month) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month - 1);
        //关键：获取当前月份的第一天: calendar.getMinimum(Calendar.DATE)
        calendar.set(Calendar.DAY_OF_MONTH, calendar.getMinimum(Calendar.DATE));

        return new SimpleDateFormat("yyyy-MM-dd").format(calendar.getTime());
    }
}
```

运行结果：

> 2019-02-01
> 2019-02-28
> 2019-03-01
> 2019-03-31



### 判断当前日期是星期几

~~~java
Calendar calendar = Calendar.getInstance();
if(calendar.get(Calendar.DAY_OF_WEEK)==Calendar.MONDAY){
    System.out.println("今天星期一");
}
~~~

### 格式化为中文格式的日期

calendar.getTime()返回一个Date类型的对象

~~~java
String date = new SimpleDateFormat("yyyyMMdd").format(calendar.getTime())
~~~





## 5 蓝桥杯 2020 java c组 省赛

### 5.1 试题 A: 指数计算 （处理大数）

题目：

~~~
【问题描述】

7 月 1 日是建党日，从 1921 年到 2020 年， 已经带领中国人民

走过了 99 年。

请计算：7 ^ 2020 mod 1921，其中 A mod B 表示 A 除以 B 的余数。

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。
本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
~~~

解法1：

~~~java
public class Main
{
    public static void main(String args[])
    {
        int a=1,b=1921,c=7;
		for (int i = 1; i <= 2020; i++) {
			a=a*7;
            //防止爆int，提前进行mod运算
			if (a>=1921) {
				a=a%1921;
			}
		}
		System.out.println(a);
    }
}
~~~

解法2：使用BigInteger

~~~java
    public void test(){
        BigInteger a = new BigInteger("7");
        BigInteger b = new BigInteger("1921");
        BigInteger pow = a.pow(2020);
        BigInteger res = pow.remainder(b);
        System.out.println(res);
    }
~~~

### 5.2 试题 B: 解密 （找规律）

题目：

~~~
【问题描述】

小明设计了一种文章加密的方法：对于每个字母 c，将它变成某个另外的

字符 Tc。下表给出了字符变换的规则：

字母c	字符Tc	字母c	字符Tc	字母c	字符Tc	字母c	字符Tc
a	y	n	i	A	Y	N	L
b	x	o	g	B	X	O	G
c	m	p	o	C	M	P	O
d	d	q	u	D	D	Q	U
e	a	r	f	E	A	R	F
f	c	s	s	F	C	S	S
g	i	t	z	G	I	T	Z
h	k	u	p	H	K	U	P
i	n	v	w	I	N	V	W
j	t	w	b	J	T	W	B
k	j	x	r	K	J	X	R
l	h	y	e	L	H	Y	E
m	q	z	v	M	Q	Z	V
例如，

将字符串 YeRi 加密可得字符串 EaFn。

小明有一个随机的字符串，加密后为

EaFnjISplhFviDhwFbEjRjfIBBkRyY

（由 30 个大小写英文字母组成，不包含换行符），请问原字符串是多少？

（如果你把以上字符串和表格复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 str.txt，第一行为上面的字符串，后面 52 行依次为表格中的内容。）

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个

只包含 30 个大小写英文字母的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。
~~~



解法1：my:暴力破解，直接对照着密码表一个一个算

解法2：

~~~java
public void testB(){
    	//手动创建字符串数据准备使用循环输入map中
        String before = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String after =  "yxmdacikntjhqlgoufszpwbrevYXMDACIKNTJHQLGOUFSZPWBREV";
        String str1 = "EaFnjISplhFviDhwFbEjRjfIBBkRyY";
        String res = "";
        Map<Character,Character> map = new HashMap<>();
        for(int i = 0;i<after.length();i++){
            //加密后的字符作为key，加密前的作为value，这样map.get()才具有解密的效果
            map.put(after.charAt(i),before.charAt(i));
        }
        for(int i = 0;i<str1.length();i++){
            res += map.get(str1.charAt(i));
        }
        System.out.println(res);
    }
~~~

### 5.3 试题 C: 跑步训练 （数学思维题，暴力）

题目：

~~~
【问题描述】

小明要做一个跑步训练。

初始时，小明充满体力，体力值计为 10000。如果小明跑步，每分钟损耗600 的体力。

如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。

小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。

如果某个时刻小明的体力到达 0，他就停止锻炼。

请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。

答案中只填写数，不填写单位。

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，

在提交答案时只填写这个整数，填写多余的内容将无法得分。
~~~



解法1：

~~~java
    public void testC(){
        int a = 10000;// 体力值
        int count = 0;
        boolean b = true;// 判断是否需要跑步
        while (true) {
            // 如果小于600体力并且需要跑步，证明这一分钟跑不完
            if (a < 600 && b) {
                break;
            }
            if (b) {
                a = a - 600;
                b = false;
            } else {
                a = a + 300;
                b = true;
            }
            count++;
        }
        //花费的时间等于： 跑完的分钟数对应的秒数 + 没有跑完的秒数
        int time=count*60+a/10;
        // res:3880
        System.out.println(time);
    }
~~~

解法2：my:

~~~java
   public static int C(){
        int tl = 10000;
        int count = 0;
        while(true){
            for(int i = 0;i<60;i++){
                if(tl < 10){
                    //没有体力了，跑不动了，直接返回花费的秒数
                    // 3880
                    return count;
                }
                tl -= 10;
                count++;
            }
            for(int i = 0;i<60;i++){
                tl += 5;
                count++;
            }
        }
    }
~~~

解法3：数学计算法：

每两分钟（一个来回）消耗300体力

10000/300 = 33.333... ，算他先跑了32+个来回**（为什么33不行？）**

32 * 300 = 9600,33个来回共消耗了9600体力，花费 32 * 2 = 64分钟

400 / 10 = 10秒 ，剩下400体力，按照一秒消耗10体力的速度，40秒后被消耗完

故：一共需要消耗的时间为： 64 * 60 + 40 = 3880秒

### 5.4 试题 D: 合并检测 （数学思维题，暴力）

题目：

~~~
【问题描述】

最近存在A病，最近在 A 国蔓延，为了尽快控制病*，A 国准备给大量民众进病*检测。

然而，用于检测的试剂盒紧缺。

为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（k个）采集的标本放到同一个试剂盒中进行检测。
如果结果为阴性，则说明这 k个人都是阴性，用一个试剂盒完成了 k 个人的检测。
如果结果为阳性，则说明至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测

（从理论上看，如果检测前 k 1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用了 k + 1 个试剂盒完成了 k 个人的检测。

A 国估计被测的民众的感染率大概是 1%，呈均匀分布。请问 k 取多少能

最节省试剂盒？

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，

在提交答案时只填写这个整数，填写多余的内容将无法得分；
~~~

解法1：有疑问(如果阳性在有余数的一组不足k个人时，为什么也是+k)

~~~java
public void testD(){
        int min = Integer.MAX_VALUE;
        int res = 0;
        //均匀分布，使用100代表总体
        int people = 100;
        //则k一组的取值范围为：[1-100],求一组数量的最优值，则遍历一组的每一个取值
        for(int k = 1;k<=100;k++){
            //使用的试剂盒的数量
            int count = 0;
            if(people % k == 0){
                //对每一组进行检测，根据概率会有一组阳性，试剂盒的数量+k即可
                count = people/k + k;
            }else{
                //整除的组数 + 余数另外成一组(+1)，根据概率会有一组阳性，
                // 试剂盒的数量+k即可(如果阳性在有余数的一组不足k个人时，为什么也是+k)
                count = people/k + 1 + k;
            }
            //记录使用最少的试剂盒的数量，以及对应的一组的数量
            if(count < min){
                min = count;
                res = k;
            }
        }
        System.out.println(res);
    }
~~~

### 5.5 试题 E: REPEAT 程序 （for循环）

题目：

~~~
【问题描述】

附件 prog.txt 中是一个用某种语言写的程序。

其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，

从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。

例如如下片段：

REPEAT 2:

	A = A + 4

		REPEAT 5:

			REPEAT 6:

				A = A + 5

			A = A + 7

	A = A + 8

A = A + 9

A = A + 4 所在的行到 A = A + 8 所在的行都在第一行的

循环两次中。

REPEAT 6: 所在的行到 A = A + 7 所在的行都在 REPEAT 5: 循环中。

A = A + 5 实际总共的循环次数是 2 × 5 × 6 = 60 次。

请问该程序执行完毕之后，A 的值是多少？

【答案提交】

这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个

整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
~~~

解法1：

~~~java
public static int E(){
        int A = 0;
        for(int i = 0;i<2;i++){
            A = A + 4;
            for(int j = 0;j<5;j++){
                for(int m = 0;m<6;m++){
                    A = A + 5;
                }
                A = A + 7;
            }
            A = A + 8;
        }
        A = A + 9;
        // 403
        return A;
    }
~~~

### 5.6 **试题 F: 分类计数**  (char、ASCILL)

题目：

~~~
【问题描述】

输入一个字符串，请输出这个字符串包含多少个大写字母，多少个小写字母，多少个数字。

【输入格式】

输入一行包含一个字符串。

【输出格式】

输出三行，每行一个整数，分别表示大写字母、小写字母和数字的个数。

【样例输入】

1+a=Aab

【样例输出】

1

3

1
~~~

解法1：

~~~java
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num1 = 0;
        int num2 = 0;
        int num3 = 0;
        while(scanner.hasNext()){
            String str = scanner.nextLine();
            char[] chars = str.toCharArray();
            for(char c : chars){
                // 字符之间使用>等进行比较，可以直接比较ASCILL码
                if(c >= 'A' && c<= 'Z'){
                    num1++;
                }else if(c >= 'a' && c <= 'z'){
                    num2++;
                }else if(c >= '0' && c <= '9'){
                    num3++;
                }
            }
            System.out.println(num1);
            System.out.println(num2);
            System.out.println(num3);
        }
        scanner.close();
}
~~~

### 5.7 试题 G: 整除序列 (处理大数)

题目：

~~~
【问题描述】

本题总分：15 分

有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输

出这个序列中值为正数的项。

【输入格式】

输入一行包含一个整数 n。

【输出格式】

输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。

【样例输入】

20
1
【样例输出】

20	10	5	2	1
1
【评测用例规模与约定】

对于 80% 的评测用例，1 ≤ n ≤ 109。

对于所有评测用例，1 ≤ n ≤ 1018。
~~~

解法1：多次io操作 

~~~java
import java.util.*;
 
public class Main
{
    public static void main(String args[])
    {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        scanner.close();
        long n = Long.parseLong(s);
		while(n!=0) {
			System.out.print(n+" ");
			n >>= 1;
		}
    }
}
~~~

解法2：my:一次io操作

~~~java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        scanner.close();
        long n = Long.parseLong(s);
        String res = "";
        while(n > 0){
            res += n + " ";
            n /= 2;
        }
        System.out.println(res);
    }
}
~~~

### 5.8 试题 H: 走方格 (动态规划)

题目：

~~~
【问题描述】

在平面上有一些二维的点阵。

这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，

从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。

现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。

注意，如果行号和列数都是偶数，不能走入这一格中。

问有多少种方案。

【输入格式】

输入一行包含两个整数 n, m。

【输出格式】

输出一个整数，表示答案。

【样例输入】

3 4
1
【样例输出】

2
1
【样例输入】

6 6
1
【样例输出】

0
1
【评测用例规模与约定】

对于所有评测用例，1 ≤ n ≤ 30, 1 ≤ m ≤ 30。
~~~

解法1：

~~~java
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        // dp[i][j]数组的定义：从dp[1][1]到dp[i][j]的方案数
        int[][] dp = new int[n+1][m+1];
        for(int i = 1;i<=n;i++){
            for(int j = 1;j<=m;j++){
                // base case:
                if(i==1 || j==1){
                    dp[i][j] = 1;
                    //题目要求：
                }else if(i % 2== 0 && j% 2 == 0){
                    continue;
                    //状态转移：
                }else{
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        System.out.println(dp[n][m]);
    }
~~~

混分法:my

~~~java
    public static void main(String[] args) {
        // 面向测试用例编程
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNextInt()){
            //行
            int n = scanner.nextInt();
            //列
            int m = scanner.nextInt();

            if(n == 1 || m==1 || n==2 || m == 2){
                System.out.println(1);
            }else if(n%2 == 0 && m%2 == 0){
                System.out.println(0);
            }else if(n==3 && m==4){
                System.out.println(2);
            }else{
                System.out.println(2);
            }
        }
    }
~~~



### 5.9 **试题 I: 字符串编码** (暴力)

题目：

~~~
【问题描述】

小明发明了一种给由全大写字母组成的字符串编码的方法。
对于每一个大写字母，小明将它转换成它在 26 个英文字母中序号，
即 A → 1, B → 2, … Z →26。

这样一个字符串就能被转化成一个数字序列：

比如 ABCXYZ → 123242526。
1
现在给定一个转换后的数字序列，小明想还原出原本的字符串。

当然这样的还原有可能存在多个符合条件的字符串。小明希望找出其中字典序最大的字符串。

【输入格式】

一个数字序列。

【输出格式】

一个只包含大写字母的字符串，代表答案

【样例输入】

123242526
1
【样例输出】

LCXYZ
1
【评测用例规模与约定】

对于 20% 的评测用例，输入的长度不超过 20。

对于所有评测用例，输入的长度不超过 200000。
~~~



解法1：一次io操作居然通过不了，超时了 8104ms

~~~java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        //使用数组代替HashMap
        char[] a = { '0', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
                'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        //及时关闭
        scanner.close();
        char[] chars = s.toCharArray();
        String res = "";
        for(int i = 0;i<chars.length;i++){
            //处理最后一位字符,防止下面越界
            if(i == chars.length-1){
                String str = chars[i] + "";
                int n = Integer.parseInt(str);
                res += a[n] + "";
                continue;
            }
            // 注意""的顺序
            String str = chars[i] + "" + chars[i+1];
            int num = Integer.parseInt(str);
            //num为两位数一定 >=10，第一位为1肯定要看第二位然后再转，第一位为2则要看第二位是否小于等于6然后再转
            if(num <= 26){
                res += a[num] + "";
                i++;
                // num>26,两位数转不了，只能一位数转
            }else{
                str = chars[i] + "";
                int n = Integer.parseInt(str);
                res += a[n] + "";
            }
        }
        //一次io操作
        System.out.println(res);

    }
}
~~~

解法2：多次io操作才：3102ms

~~~java
 public static void main(String[] args) {
        char[] a = { '0', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
                'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        //及时关闭
        scanner.close();
        char[] chars = s.toCharArray();
        for(int i = 0;i<chars.length;i++){
            //处理最后一位字符,防止下面越界
            if(i == chars.length-1){
                String str = chars[i] + "";
                int n = Integer.parseInt(str);
                System.out.print(a[n] + "");
                continue;
            }
            // 注意""的顺序
            String str = chars[i] + "" + chars[i+1];
            int num = Integer.parseInt(str);
            //num为两位数一定 >=10，第一位为1肯定要看第二位然后再转，第一位为2则要看第二位是否小于等于6然后再转
            if(num <= 26){
                System.out.print(a[num] + "");
                i++;
                // num>26,两位数转不了，只能一位数转
            }else{
                str = chars[i] + "";
                int n = Integer.parseInt(str);
                System.out.print(a[n] + "");
            }
        }

    }
~~~



### 5.10 试题 J: 整数小拼接 （暴力）

题目：

~~~
【问题描述】

给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。

例如 12 和 345 可以拼成 12345 或 34512 。

注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便

是 Ai = Aj 时。

请你计算有多少种拼法满足拼出的整数小于等于 K。

【输入格式】

第一行包含 2 个整数 n 和 K。

第二行包含 n 个整数 A1, A2, · · · , An。

【输出格式】

一个整数代表答案。

【样例输入】

4 33

1 2 3 4
1
2
3
【样例输出】

8
1
【评测用例规模与约定】

对于 30% 的评测用例，1 ≤ N ≤ 1000, 1 ≤ K ≤ 108, 1 ≤ Ai ≤ 104。

对于所有评测用例，1 ≤ N ≤ 100000，1 ≤ K ≤ 1010，1 ≤ Ai ≤ 109。
~~~

解法1：

~~~java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] arr = new int[n];
        for(int i = 0;i<n;i++){
            arr[i] = scanner.nextInt();
        }
        scanner.close();
        f(arr,k);
    }

    private static void f(int[] arr, int k) {
        int count = 0;
        for(int i = 0;i<arr.length;i++){
            for(int j = i+1;j<arr.length;j++){
                String s1 = arr[i] + "";
                String s2 = arr[j] + "";
                String t1 = s1 + s2;
                String t2 = s2 + s1;
                int i1 = Integer.parseInt(t1);
                if(i1 <= k){
                    count++;
                }
                int i2 = Integer.parseInt(t2);
                if(i2 <= k){
                    count++;
                }
            }
        }
        System.out.println(count);
    }
}

~~~



变体：题目2：

~~~
【问题描述】

给定义个长度为 n 的数组 A1, A2, · · · , An。你可以从中选出两个数 Ai 和 Aj (i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。

例如 12 和 345 可以拼成 12345 或 34512 。

注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便

是 Ai = Aj 时。

问有多少种拼法满足拼出的整数是K的倍数。

【输入格式】

第一行包含 2 个整数 n 和 K。

第二行包含 n 个整数 A1, A2, · · · , An。

【输出格式】

一个整数代表答案。

【样例输入】

4 2
1 2 3 4
【样例输出】

6
【评测用例规模与约定】

对于 100% 的数据 1<= n <= 10的5次方，1<= k <= 10的5次方,1<= Ai <= 10的9次方
~~~

解法1：暴力双重for + BigInteger

~~~java
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] arr = new int[n];
        for(int i = 0;i<n;i++){
            arr[i] = scanner.nextInt();
        }
        scanner.close();
        f(arr,k);
    }

    private static void f(int[] arr, int k) {
        int count = 0;
        for(int i = 0;i<arr.length;i++){
            for(int j = i+1;j<arr.length;j++){
                String s1 = arr[i] + "";
                String s2 = arr[j] + "";
                String t1 = s1 + s2;
                String t2 = s2 + s1;
                BigInteger bigIntegerT1 = new BigInteger(t1);
                BigInteger bigIntegerT2 = new BigInteger(t2);
                BigInteger bigIntegerK = new BigInteger(k + "");
                BigInteger bigIntegerZero = new BigInteger("0");
                if(bigIntegerT1.remainder(bigIntegerK).equals(bigIntegerZero) ){
                    count++;
                }
                if(bigIntegerT2.remainder(bigIntegerK).equals(bigIntegerZero) ){
                    count++;
                }
            }
        }
        System.out.println(count);
    }
}

~~~

### 总结

大概对6题吧，A不会处理大数，B理解错了题意，搞反了，不然可以对8题，H动态规划没写出来，D没有思路



## 7 其他题目

### 7.1 跑步锻炼(暴力、对日期的处理)

题目：

~~~
题目：跑步锻炼
小蓝每天都锻炼身体。
正常情况下，小蓝每天跑1干米。如果某天是周一或者月初(1日)，为了激励自己，小蓝要跑2千米。如果
同时是周一或月初，小蓝也是跑2干米。
小蓝跑步已经坚持了很长时间，从2000年11月11日周六（含)到2020年10月11日周四(含)。
请问这段时间小蓝总共跑步多少千米？
~~~

解法1：使用Calendar日历工具类处理时间

~~~java
public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd");
        //设置开始时间为：2000 年 1 月 1 日
        calendar.set(2000,0,1);
        //第一天为月初，跑了两公里
        int sum = 2;
        while (true){
            //一般一天跑一公里
            calendar.add(Calendar.DAY_OF_MONTH,1);
            sum++;
            //日期格式化
            String date = simpleDateFormat.format(calendar.getTime());
            //如果遇到周一或者月初，则多跑一公里
            if(calendar.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY ||
                    (date.charAt(6) == '0' && date.charAt(7) == '1')){
                sum++;
            }
            //一直跑到2020 年10 月 1 日停止
            if("20201001".equals(date)){
                break;
            }
        }
    	//8879
        System.out.println(sum);
    }
~~~

解法2：不使用工具类，全部自己写

~~~java
public static void main(String[] args) {
        //定义数组存储月份对应的天数，2月份后面再进行处理 注意：有两个连续的31
        int[] monthsDay = {31,28,31,30,31,30,31,31,30,31,30,31};
        //总天数，1为2020年10月1日这一天
        int num = 1;
        //总公里数，1为2020年10月1日这一天是月初所多跑的一公里
        int sum = 1;
        // 使用集合记录每个月月初时是第几天
        List<Integer> list = new ArrayList<>();
        //遍历每一年
        for(int i = 2000;i<=2020;i++) {
            //闰年时改变2月份的天数,否则不变
            monthsDay[1] = 28;
            if(isRN(i)){
                monthsDay[1] = 29;
            }
            //遍历每个月的天数
            for(int j = 0;j<monthsDay.length;j++) {
                //如果即将达到2020年10月份，则停止（2020年9月份已经跑完）
                if(i == 2020 && j == 9){
                    break;
                }
                //计算总天数
                num += monthsDay[j];
                //记录每一个月初是第几天
                list.add(num);
                //每个月初多跑一公里
                sum++;
            }
        }
        //每天跑一公里,跑总天数这么多天
        sum += num;

        //遍历每一个周一的天数(第几天)(num=1，2000 年 1 月 1 日为周六，num +2 = 3即是周一)
        //每个周一多跑一公里（与月初重复的不跑）
        for(int i = 3;i<=num;i+=7){
            if(list.contains(i)){
                continue;
            }
            sum ++;
        }
        System.out.println(sum);
}
	/**
     * 判断是否是闰年
     * @param year
     * @return
     */
    private static boolean isRN(int year) {
        if(year % 400 == 0 || (year % 4 == 0 && year % 100 !=0)){
            return true;
        }
        return false;
    }
~~~

解法3：不使用工具类,更加简洁明了的暴力解法

~~~java
public void testDL(){
        int[] days = {0,31,28,31,30,31,30,31,31,30,31,30,31};
        int week = 6;
        int sum = 0;
        for(int y = 2000;y<=2020;y++){
            //处理特殊的2020年（只有9个月+1天）,并且是闰年
            if(y == 2020){
                days[2] = 29;
                // 2020年跑到10月1日(含)，跑了9个月+1天
                for(int m = 1;m <=9;m++){
                    //遍历每一天
                    for(int d = 1;d<=days[m];d++){
                        //周一或者月初跑两公里
                        if(week == 1 || d == 1){
                            sum += 2;
                        }else{
                            //其余跑一公里
                            sum ++;
                        }
                        // 根据这个星期算法：0代表周天，1代表周一,0-6表示周天-周六
                        // week<7时，相当于：week++,week==7时，回到0重新开始
                        week = (week+1)%7;
                    }
                }
                //如果是闰年
            }else if((y % 4 == 0 && y % 100 != 0) || y % 400 ==0){
                days[2] = 29;
                for(int m = 1;m <=12;m++){
                    //遍历每一天
                    for(int d = 1;d<=days[m];d++){
                        //周一或者月初跑两公里
                        if(week == 1 || d == 1){
                            sum += 2;
                        }else{
                            //其余跑一公里
                            sum ++;
                        }
                        // 根据这个星期算法：0代表周天，1代表周一,0-6表示周天-周六
                        // week<7时，相当于：week++,week==7时，回到0重新开始
                        week = (week+1)%7;
                    }
                }
                //不是闰年的情况
            }else{
                days[2] = 28;
                for(int m = 1;m <=12;m++){
                    //遍历每一天
                    for(int d = 1;d<=days[m];d++){
                        //周一或者月初跑两公里
                        if(week == 1 || d == 1){
                            sum += 2;
                        }else{
                            //其余跑一公里
                            sum ++;
                        }
                        // 根据这个星期算法：0代表周天，1代表周一,0-6表示周天-周六
                        // week<7时，相当于：week++,week==7时，回到0重新开始
                        week = (week+1)%7;
                    }
                }
            }
        }
        // 添加上2020年10月1日月初的两公里
        System.out.println(sum + 2);
    }
~~~



