# 数组与链表

# (1) 数组

在处理数组和链表相关问题时，**双指针技巧**是经常用到的，双指针技巧主要分为两类：**左右指针**和**快慢指针**。

所谓左右指针，就是两个指针相向而行或者相背而行；

所谓快慢指针，就是两个指针同向而行，一快一慢。

## 1 快慢指针

快慢指针技巧的应用：

1.是让你在**有序**数组、链表中**原地**去重。或者在数组中原地删除目标元素。

2.「**滑动窗口算法**」。

### 题型1：

快指针 fast 走在前面**探路**，找到一个目标元素就让 slow 前进一步并且赋值给 slow 。这样，就**保证了 nums[0..slow] 都是目标的元素**了。

例如：

#### 题目1 在**有序**数组中**原地**去重

数组：

https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/

~~~java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        for(int fast = 1;fast < nums.length;fast++){
            // 快指针始终在慢指针前面，那么只要保证快指针不越界，慢指针也就不会越界
            if(nums[fast] != nums[slow]){
                slow++;
                // 我们让慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不重复的元素就让 slow 前进一步并且赋值给 slow 。这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果。
                nums[slow] = nums[fast];
            }
        }
        return slow + 1;
    }
}
~~~

#### 题目2 在有序链表中原地去重

链表：

https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null){
            return null;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast != null){
            if(slow.val != fast.val){
                slow = slow.next;
                slow.val = fast.val;
            }
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
~~~

#### 题目3 对数组中的某些元素进行「**原地删除**」

对数组进行删除，算法上一般指的是逻辑删除，只是把要删除的元素覆盖了，数组的长度并没有改变。

slow指针什么都不需要管，只需要接收fast指针传过来的值然后向前一步即可，而fast指针只寻找不等于目标值的值，所以结果为slow得到的全部是不等于目标值的值，一步步覆盖原数组，0到slow这个区间即删除目标值后的结果。

https://leetcode.cn/problems/remove-element/

快慢指针之原地修改数组

~~~java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        // 输入：nums = 1,2,3,4,5,6,7 val = 5  结果：nums = 1,2,3,4,6,7,7
        for(int fast = 0;fast<nums.length;fast++){
            // 如果fast探路的结果不等于目标元素
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;// 实际上没有删除目标元素，只是只看0到slow的索引相当于删除了
    }
}
~~~

#### 题目4 移动0

https://leetcode.cn/problems/move-zeroes/description/

~~~java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        // 对数组中的某些元素进行「原地删除」的算法，这里的元素为0,删除前nums = [1,2,0,3,0,1] 删除后 nums = [1,2,3,1,0,1]
        for(int fast = 0;fast<nums.length;fast++){
            if(nums[fast] != 0){
                nums[slow] = nums[fast];
                slow++;
            }
        }
        for(int i = slow;i<nums.length;i++){
            nums[i] = 0;
        }
    }
}
~~~

### 题型2：滑动窗口算法

见滑动窗口.md

## 2 左右指针的常见应用

从**中心向两端**扩散与从**两端向中间**扩散的双指针技巧。

## (1) 从**两端向中间**扩散 

### 二分查找一个数

​	略

### n数之和问题

#### 两数之和 II（二分查找变体）

https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/

数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。

~~~java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        // 充分利用题目条件
        // 非递减顺序排列 :使用类似二分查找的方法
        int left = 0;
        int right = numbers.length - 1;
        // 因为不可以重复使用相同的元素，所以while的条件不能取等
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum > target){
                right--;
            }else if(sum < target){
                left++;
            }else if(sum == target){
                // 返回的数组下标从1开始计算
                return new int[]{left+1,right+1};
            }
        }
        // 每个输入 只对应唯一的答案 
        return new int[]{-1,-1};
    }
}
~~~



### 回文串判断

判断是否为回文串，**从两端向中心靠近**

~~~java
boolean isPalindrome(String s) {
    // 一左一右两个指针相向而行
    int left = 0, right = s.length() - 1;
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

~~~

### LCR 139. 训练计划 I (剑指offer)

整数数组 `actions` 记录一系列项目编号,需要将所有奇数编号调整至偶数编号之前。请将调整后的编号以 **数组** 形式返回。

https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/?envType=study-plan-v2&envId=coding-interviews

思路：

1. 指针 i 从左向右寻找偶数；
2. 指针 j 从右向左寻找奇数；
3. 将 偶数 actions[i]和 奇数 actions[j] 交换。

可始终保证： 指针 i 左边都是奇数，指针 j 右边都是偶数 。

解法1：路人 **从两端向中心靠近的双指针技巧** 时间复杂度O(N)，空间复杂度O(1)

~~~java
class Solution {
    public int[] trainingPlan(int[] actions) {
        int i = 0, j = actions.length - 1, tmp;
        while(i < j) {
            // x & 1 位运算 等价于 x mod 2取模运算，皆可用于判断数字奇偶性。
            while(i < j && (actions[i] & 1) == 1) i++;
            while(i < j && (actions[j] & 1) == 0) j--;
            tmp = actions[i];
            actions[i] = actions[j];
            actions[j] = tmp;
        }
        return actions;
    }
}
~~~



## (2) 从中间向两端扩散

#### 最长回文子串

https://leetcode.cn/problems/longest-palindromic-substring/description/

最坏：O(n的平方)

**从中心向两端扩散的双指针技巧**。

~~~java
class Solution {
    public String longestPalindrome(String s) {
        if(s == null){
            return "";
        }
        if(s.length() == 1){
            return s;
        }
        String res = "";
        for(int i = 0;i<s.length();i++){
            String str1 = fun(s,i,i);
            String str2 = fun(s,i,i + 1);
            res = res.length() > str1.length() ? res : str1;
            res = res.length() > str2.length() ? res : str2;
        }
        return res;
    }
    // 返回s中以left,right为中心的最长回文子串
    // left==right则以一个字符为中心，寻找到的一定是一个总字符数量为奇数的回文串，left == right - 1,则找到的一定是一个总字符数量为偶数的回文串
    public String fun(String s,int left,int right){
        while((left >= 0 && right < s.length()) && 
        s.charAt(left) == s.charAt(right)){
            left--;
            right++;
        }
        return s.substring(left+1,right);
    }
}
~~~

解法2：my80% labuladong改，避免多次字符串截取影响性能，使用数组存储回文字符串的索引范围，最坏：O(n的平方)

~~~java
class Solution {
    public String longestPalindrome(String s) {
        if(s == null){
            return "";
        }
        if(s.length() == 1){
            return s;
        }
        String res = "";
        // 记录最长的索引范围
        int[] resIndex = new int[2];
        for(int i = 0;i<s.length();i++){
            int[] index1 = fun(s,i,i);
            int[] index2 = fun(s,i,i + 1);
            int len1 = index1[1] - index1[0];
            int len2 = index2[1] - index2[0];
            int resLen = resIndex[1] - resIndex[0];
            // 更新最大的索引范围
            if(len1 >= len2 && len1 > resLen){
                resIndex[0] = index1[0];
                resIndex[1] = index1[1];
            }else if(len2 >= len1 && len2 > resLen){
                resIndex[0] = index2[0];
                resIndex[1] = index2[1];
            }
        }
        return s.substring(resIndex[0],resIndex[1]);
    }
    // 返回s中以left,right为中心的回文串的索引范围
    // left==right则以一个字符为中心，寻找到的一定是一个总字符数量为奇数的回文串，left == right - 1,则找到的一定是一个总字符数量为偶数的回文串
    public int[] fun(String s,int left,int right){
        while((left >= 0 && right < s.length()) && 
        s.charAt(left) == s.charAt(right)){
            left--;
            right++;
        }
        return new int[]{left+1,right};
    }
}
~~~






## 3 二维数组的花式遍历技巧

labuladong文章中的题目练习。

labuladong原文：https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/er-wei-shu-150fb/

### 1 原地顺时针旋转二维数组

https://leetcode.cn/problems/rotate-image/description/

解法1：labuladong 100%O(n平方) 时间复杂度  使用 对角线对称（镜像对称）+ 反转  原地修改

比较通用强大，可以原地修改 O(1)空间复杂度，求逆时针旋转后的二维数组也比较好求

~~~java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        if(n == 1 && matrix[0].length == 1){
            return;
        }
        // 要把图像顺时针旋转 90 度:
        //1.根据左上到右下这条对角线进行对称处理，交换这条对角线上面对称的元素
        for(int i = 0;i < n;i++){
            for(int j = i + 1;j < n;j++){
                // 交换
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        //2.反转每一行
        for(int[] arr : matrix){
            reverse(arr);
        }
    }

    public void reverse(int[] arr){
        int left = 0;
        int right = arr.length - 1;
        while(left < right){
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}
~~~

解法2：蓝桥杯中的题目: 寻找各种遍历方式 O(n平方)空间复杂度 不能原地修改，O(n平方)空间复杂度

~~~java
public class Practice13 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        System.out.println(n);
        System.out.println(m);
        int[][] arrs = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                arrs[i][j] = scanner.nextInt();
            }
        }
        scanner.close();
        //1 老师版本：从第一列到最后一列 从下往上遍历
        for(int i = 0;i<m;i++){
            for(int j = n-1;j>=0;j--){
                System.out.print(arrs[j][i]+" ");
            }
            System.out.println();
        }

        //int[][] newArr  = rotate(arrs);
//        for (int[] arr : newArr) {
//            for (int i = 0; i < arr.length; i++) {
//                System.out.print(arr[i] + " ");
//            }
//            System.out.println();
//        }
    }

    /**
     * 2 my:
     * 传入一个二维数组，返回一个这个数组顺时针旋转90度后的数组
     * @param arrs
     * @return
     */
    private static int[][] rotate(int[][] arrs) {
        int col = arrs.length;
        int row = arrs[0].length;
        int[][] res = new int[row][col];
        // 在最后一行到第一行从左往右遍历
        for(int i = arrs.length-1;i>=0;i--){
            for(int j = 0;j<arrs[0].length;j++){
                 // 凑数组的下标
                 res[j][2-i] = arrs[i][j];
            }
        }
        return res;
    }
}

~~~



### 2 螺旋遍历二维数组 I

https://leetcode.cn/problems/spiral-matrix/description/

解法1：my100% labuladong改 维护4个边界变量来实现螺旋遍历

~~~java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        List<Integer> res = new ArrayList<>();
        if(n == 0){// 根据输入判断特殊情况，良好习惯，判断后不管代码是否能够处理，都不需要再单独把特殊情况带入代码进行验证了
            return res;
        }else if(m == 1 && n == 1){
            res.add(matrix[0][0]);
            return res;
        }
        // 确定4个边界 左闭右闭
        int leftBorder = 0,rightBorder = n - 1;
        int upperBoder = 0,lowerBorder = m - 1;
        int count = m * n;
        while(res.size() < count){// while(true)也可以
            // 1 遍历上侧的左右边界
            for(int i = leftBorder;i <= rightBorder;i++){
                res.add(matrix[upperBoder][i]);
            }
            // 每次for遍历一次后都判断一次是否已经遍历完数组了
            if(res.size() == count){
                break;
            }
            // 上侧边界下移
            upperBoder++;
            // 2 遍历右侧的上下边界
            for(int i = upperBoder;i <= lowerBorder;i++){
                res.add(matrix[i][rightBorder]);
            }
            if(res.size() == count){
                break;
            }
            // 右侧边界左移
            rightBorder--;
            // 3 遍历下侧的右至左的边界
            for(int i = rightBorder;i >= leftBorder;i--){
                res.add(matrix[lowerBorder][i]);
            }
            if(res.size() == count){
                break;
            }
            // 下侧的边界上移
            lowerBorder--;
            //4 遍历左侧的下到上的边界
            for(int i = lowerBorder;i>=upperBoder;i--){
                res.add(matrix[i][leftBorder]);
            }
            if(res.size() == count){
                break;
            }
            // 左侧的边界右移
            leftBorder++;
        }
        return res;
    }
}
~~~

### 3 螺旋遍历二维数组 剑指offer

https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/

解法1：my98% 定义4个边界变量来实现螺旋遍历

~~~java
class Solution {
    public int[] spiralArray(int[][] array) {
        if(array.length == 0){
            return new int[]{};
        }else if(array.length == 1 && array[0].length == 0){
            return new int[]{};
        }
        int m = array.length;
        int n = array[0].length;
        int index = 0;
        int[] res = new int[m * n];
        // 定义4个边界变量 左闭右闭
        int leftBorder = 0,rightBorder = n - 1;
        int upperBorder = 0,lowerBorder = m - 1;
        while(true){
            // 上
            for(int i = leftBorder;i <= rightBorder;i++){
                res[index] = array[upperBorder][i];
                index++;
            }
            if(index == m * n){
                break;
            }
            upperBorder++;
            // 右
            for(int i = upperBorder;i <= lowerBorder;i++){
                res[index] = array[i][rightBorder];
                index++;
            }
            if(index == m * n){
                break;
            }
            rightBorder--;
            // 下
            for(int i = rightBorder;i >= leftBorder;i--){
                res[index] = array[lowerBorder][i];
                index++;
            }
            if(index == m * n){
                break;
            }
            lowerBorder--;
            // 左
            for(int i = lowerBorder;i >= upperBorder;i--){
                res[index] = array[i][leftBorder];
                index++;
            }
            if(index == m * n){
                break;
            }
            leftBorder++;
        }

        return res;

    }
}
~~~



### 4 螺旋遍历二维数组 II

https://leetcode.cn/problems/spiral-matrix-ii/description/

解法1：my100% 维护4个边界变量来实现螺旋遍历

~~~java
class Solution {
    public int[][] generateMatrix(int n) {
        if(n == 1){
            return new int[][]{{1}};
        }
        int[][] matrix = new int[n][n];
        // 定义value变量进行赋值
        int value = 1;
        // 4个边界变量
        int leftBorder = 0,rightBorder = n - 1;
        int upperBorder = 0,lowerBorder = n - 1;
        while(true){
            // 遍历上侧的左至右边界
            for(int i = leftBorder;i <= rightBorder;i++){
                matrix[upperBorder][i] = value;
                value++;
            }
            // 判断是否全部遍历赋值完毕
            if(value == n * n + 1){
                break;
            }
            // 上侧边界下移
            upperBorder++;
            // 遍历右侧的上至下边界
            for(int i = upperBorder;i <= lowerBorder;i++){
                matrix[i][rightBorder] = value;
                value++;	
            }
            if(value == n * n + 1){
                break;
            }
            // 右侧边界左移
            rightBorder--;
            // 遍历下侧的右至左边界
            for(int i = rightBorder;i >= leftBorder;i--){
                matrix[lowerBorder][i] = value;
                value++;
            }
            if(value == n * n + 1){
                break;
            }
            // 下侧边界上移
            lowerBorder--;
            // 遍历左侧边界的下至上边界
            for(int i = lowerBorder;i >= upperBorder;i--){
                matrix[i][leftBorder] = value;
                value++;
            }
            if(value == n * n + 1){
                break;
            }
            // 左侧边界右移
            leftBorder++;
        }
        return matrix;

    }
}
~~~



# (2)链表

 链表的类型：

-  单向链表

-  双向链表

-  循环链表


链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

链表是通过指针域的指针来链接在内存中各个节点。

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。数组的查询很快O(1)。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

## 题型1 双指针



**链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**。

### 合并两个有序链表(hot100)

https://leetcode.cn/problems/merge-two-sorted-lists/description/

思路：自己创建一个链表（使用上虚拟头结点技巧）来存储结果，两个指针遍历两个链表的每个节点进行比较，把节点中值比较小的记录到结果链表中，while循环退出后，某个链表仍然有节点没有遍历，再遍历这个链表的节点。

解法1：labuladong100%O(N) 新建一个存储结果的链表，配合dummy节点解决

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null){
            return list2;
        }else if(list2 == null){
            return list1;
        }
        // 链表都需要的：另外使用一个变量记录头节点
        ListNode head1 = list1;
        ListNode head2 = list2;
        // 要新建一个存储结果的链表，那就创建一个虚拟头节点dummy，每次比较两个排序链表中最小的一个添加到dummy中
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        while(head1 != null && head2 != null){
            if(head1.val <= head2.val){
                p.next = head1;
                head1 = head1.next;
            }else{
                p.next = head2;
                head2 = head2.next;
            }
            // 最好是这里 断开链表的连接
            p = p.next;
        }
        // 退出循环时，肯定有一个head为null，另一个head的节点还没有添加到dummy链表中
        // 添加剩下的节点
        if(head1 == null){
            p.next = head2;
        }else if(head2 == null){
            p.next = head1;
        }
        // 返回dummy链表
        return dummy.next;
    }
}
~~~

解法2：改进版本：无脑断开原链表的连接

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null){
            return list2;
        }else if(list2 == null){
            return list1;
        }
        // 链表都需要的：另外使用一个变量记录头节点
        ListNode head1 = list1;
        ListNode head2 = list2;
        // 要新建一个存储结果的链表，那就创建一个虚拟头节点dummy，每次比较两个排序链表中最小的一个添加到dummy中
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        while(head1 != null && head2 != null){
            if(head1.val <= head2.val){
                p.next = head1;
                p = p.next;
                head1 = head1.next;
            }else{
                p.next = head2;
                p = p.next;
                head2 = head2.next;
            }
            // 保险起见：断开原链表的连接
            p.next = null;
        }
        // 退出循环时，肯定有一个head为null，另一个head的节点还没有添加到dummy链表中
        // 添加剩下的节点
        if(head1 == null){
            p.next = head2;
        }else if(head2 == null){
            p.next = head1;
        }
        // 返回dummy链表
        return dummy.next;
    }
}
~~~



### 分隔链表（拆分链表）

https://leetcode.cn/problems/partition-list/description/

思路：把单个链表拆分为两条链表后再连接在一起，把链表拆分为（新建链表，使用虚拟头结点开头）：小于目标值的节点组成的链表 与 小于目标值的节点组成的链表（要拆的干净，记得把原链表的节点断开），再连接这两个链表即可。

解法1：labuladong100% O(N)

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        if(head == null){
            return null;
        }else if(head.next == null){
            return head;
        }
        ListNode p = head;
        ListNode dummy1 = new ListNode(-1),p1 = dummy1;
        ListNode dummy2 = new ListNode(-1),p2 = dummy2;
        while(p != null){
            if(p.val >= x){
                p1.next = p;
                p1 = p1.next;
            }else{
                p2.next = p;
                p2 = p2.next;
            }
            // 不能直接p = p.next; 要断开原链表的指向！
            // 记录下一个原链表的节点
            ListNode temp = p.next;
            // 断开原链表的指向
            p.next = null;
            // 为了继续遍历原链表，移动p的位置指向下一个原链表的节点
            p = temp;
        }
        // 值小的链表连接值大的链表
        p2.next = dummy1.next;
        return dummy2.next;
    }
}
~~~





### 合并k个有序链表(hot100)

https://leetcode.cn/problems/merge-k-sorted-lists/

思路：转换为合并两个有序链表的不断重复：合并两个有序链表后的链表作为一条新的链表与下一个链表再次进行合并。

解法1：my  16% O(n*N) N为某个链表的节点数量

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    ListNode dummy = new ListNode(-1);
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0){
            return null;
        }else if(lists.length == 1){
            return lists[0];
        }
        for(ListNode node : lists){
            fun(dummy.next,node);
        }
        return dummy.next;
    }
    // 合并两个有序链表
    public void fun(ListNode head1,ListNode head2){
        if(head1 == null){
            dummy.next = head2;
            return;
        }
        ListNode m = new ListNode(-1),n = m;
        ListNode p1 = head1;
        ListNode p2 = head2;
        while(p1 != null && p2 != null){
            if(p1.val <= p2.val){
                n.next = p1;
                p1 = p1.next;
            }else{
                n.next = p2;
                p2 = p2.next;
            }
            n = n.next;
        }
        if(p1 == null){
            n.next = p2;
        }
        if(p2 == null){
            n.next = p1;
        }
        dummy.next = m.next;
    }
}
~~~

解法2：路人 递归 + 合并两个有序链表 100% 时间复杂度？ 递归子节点数 * 每次递归的复杂度

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists, 0, lists.length - 1);
    }
    // 递归函数的定义：传入数组的索引l与r，合并索引l到r的所有有序链表
    public ListNode merge(ListNode[] lists, int l, int r) {
        if (l == r) {
            return lists[l];
        }
        if (l > r) {
            return null;
        }
        int mid = (l + r) >> 1;
        // 核心逻辑：合并索引l到r的所有有序链表 = l到mid的链表合并后 与 合并mid到r的链表合并后 再进行合并。
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
	// 合并两个有序链表
    public ListNode mergeTwoLists(ListNode l1, ListNode l2){
        if(l1 == null || l2 == null){
            return l1 != null ? l1 : l2;
        }
        ListNode head = new ListNode(0);
        ListNode list = head;
        while(l1 != null && l2 != null){
            if(l1.val > l2.val){
                list.next = l2;
                l2 = l2.next;
            }else{
                list.next = l1;
                l1 = l1.next;
            }
            list = list.next;
        }
        list.next = (l1 != null ? l1 : l2);
        return head.next;
    }
}
~~~

解法3：labuladong优先级队列(二叉堆)70%  PriorityQueue< ListNode>

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        //处理特殊情况
        int len = lists.length;
        if(lists==null || len==0){
            return null;
        }
        //如何快速找到k个有序链表的最小值?
        //使用数据结构：优先级队列,指定存储元素的对象以及排序方式（按照头结点升序）
        PriorityQueue<ListNode> queue = new PriorityQueue<>(len,(n1,n2)-> n1.val-n2.val);
        //添加元素进入优先级队列
        for(ListNode list: lists){
            if(list!=null){
                queue.offer(list);
            }
        }
        //使用虚拟头结点进行记录
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        //开始合并链表
        while(!queue.isEmpty()){
            //升序排的优先级队列中poll出来的就是含有最小value的结点
            ListNode minNode = queue.poll();
            p.next = minNode;
            //更新queue中的值
            if(minNode.next!=null){
                queue.offer(minNode.next);
            }
            p = p.next;
        }
        return dummy.next;

    }
}
~~~

优先队列 `pq` 中的元素个数最多是 `k`，所以一次 `poll` 或者 `add` 方法的时间复杂度是 `O(logk)`；所有的链表节点都会被加入和弹出 `pq`，**所以算法整体的时间复杂度是 `O(Nlogk)`，其中 `k` 是链表的条数，`N` 是这些链表的节点总数**。



### 删除链表的倒数第 N 个结点(hot100)

解法1：labuladong100% 寻找链表的倒数节点技巧  + 虚拟头结点技巧（处理特殊情况）

思路：快指针先走n步，慢指针再与快指针一起走，快指针为null时，慢指针的指向即为所求

难点：对各种特殊情况的处理(例如：head = [1,2],n = 2)，处理没有思路时，可以尝试使用虚拟头结点技巧

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 单链表常用技巧:快慢指针寻找链表的倒数节点
        if(head.next == null){
            return null;
        }
        ListNode dummy = new ListNode(-1),p = dummy;
        p.next = head;
        // 寻找倒数第n + 1个节点
        ListNode node = findLastNode(dummy,n + 1);
        // 删除倒数第n个节点 即使n=1 node.next也不会为null
        node.next = node.next.next;
        return dummy.next;
    }
    // 寻找链表的倒数第n个节点
    public ListNode findLastNode(ListNode head,int n){
        ListNode fast = head,slow = head;
        // 快指针先走n步
        int i = 0;
        while(i < n){
            // 不对fast是否为null进行判断，因为传入的head包含dummy节点，n不会超过head的数量，不会导致越界,while()中判断后会处理不了
            fast = fast.next;
            i++;
        }
        // 慢指针再与快指针一起走
        while(fast != null){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
~~~

### 链表的中间结点

思路：慢指针走一步，快指针走两步，当快指针为null或即将为null时，slow的指向则是链表的中间结点

注意：如果链表的数量为奇数，那么这个算法(初始化都指向第一个节点)的结果slow指向的为中间节点没错，但是如果链表的数量为**偶数**，那么slow指向的是中间的两个节点中**偏右的节点**。

解法1：labuladong100% 快慢指针寻找链表的中点

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        if(head.next == null){
            return head;
        }else if(head.next.next == null){
            return head.next;
        }
        // 快慢指针寻找链表的中间节点
        ListNode slow = head,fast = head; // fast与slow初始化都指向第一个节点
        // 当快指针为null或即将为null时，slow的指向则是链表的中点
        while(fast!=null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
~~~

这样写的话，当链表节点的数量为偶数时，slow指针指向的就是中间偏左的节点了：

~~~java
	   ListNode fast = head.next, slow = head; // fast初始化指向第二个节点
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
~~~



### 判断链表是否包含环(hot100)

解法1：labuladong

思路：每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

~~~java
boolean hasCycle(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
        // 快慢指针相遇，说明含有环
        if (slow == fast) {
            return true;
        }
    }
    // 不包含环
    return false;
}

~~~

### 环形链表 ||(hot100)

https://leetcode.cn/problems/linked-list-cycle-ii/description/

思路：每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

解法1：labuladong 100% 快慢指针，两次相遇后得到答案

~~~java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null){
            return null;
        }
        //设置快慢指针
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            //相遇则表示有环
            if(slow==fast){
                //选择一个指针回到头节点，与另一个指针保存速度一致前进
                slow = head;
                while(slow!=fast){
                    slow = slow.next;
                    fast = fast.next;
                }
                //再次相遇时即为链表开始入环的第一个节点
                return slow;
            }
        }
        //快指针为null则表示没有环
        return null;
    }
}
~~~

### 相交链表(hot100)

https://leetcode.cn/problems/intersection-of-two-linked-lists/

思路：判断两个链表是否相交：指针遍历完一个链表后面去遍历另一个链表，使两个指针遍历相同的节点数量，如果两个指针相遇，则证明两个链表是相交的。

解法1：labuladong100% O(m+n) 双指针

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == headB){
            return headA;
        }
        ListNode p1 = headA;
        ListNode p2 = headB;
        // p1 == p2时，要么两个指针相遇了，要么两个指针都指向null
        while(p1 != p2){
            p1 = (p1 != null ? p1.next : headB);
            p2 = (p2 != null ? p2.next : headA);
        }
        return p1;
    }
}
~~~

解法2：

思路：想象一个相交链表，把它转换为环形链表，这样题目所求就是求入环的第一个节点了

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == headB){
            return headA;
        }
        
        ListNode p1 = headA;
        while(p1.next != null){
            p1 = p1.next;
        }
        // 连接两个链表
        p1.next = headB;
        ListNode slow = headA,fast = headA;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            // 有环
            if(slow == fast){
                slow = headA;
                while(slow != fast){
                    slow = slow.next;
                    fast = fast.next;
                }
                // return 前把链表改回去
                p1.next = null;
                return slow;
            }
        }
        // 无环
        // return 前把链表改回去
        p1.next = null;
        return null;

    }
}
~~~

思路：「寻找两条链表的交点」的核心在于让 `p1` 和 `p2` 两个指针能够同时到达相交节点 `c1`，那么可以分别统计两条链表的长度，差值表示非公共部分的长度差，那么让长链表的指针先走差值的步数，再齐头并进，那么如果两个指针相等则是相交的位置。

解法3：路人 O(m+n)

~~~java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int lenA = 0, lenB = 0;
    // 计算两条链表的长度
    for (ListNode p1 = headA; p1 != null; p1 = p1.next) {
        lenA++;
    }
    for (ListNode p2 = headB; p2 != null; p2 = p2.next) {
        lenB++;
    }
    // 让 p1 和 p2 到达尾部的距离相同
    ListNode p1 = headA, p2 = headB;
    if (lenA > lenB) {
        for (int i = 0; i < lenA - lenB; i++) {
            p1 = p1.next;
        }
    } else {
        for (int i = 0; i < lenB - lenA; i++) {
            p2 = p2.next;
        }
    }
    // 看两个指针是否会相同，p1 == p2 时有两种情况：
    // 1、要么是两条链表不相交，他俩同时走到尾部空指针
    // 2、要么是两条链表相交，他俩走到两条链表的相交点
    while (p1 != p2) {
        p1 = p1.next;
        p2 = p2.next;
    }
    return p1;
}

~~~

### 反向输出链表

https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/?envType=study-plan-v2&envId=coding-interviews

解法1：my62% O(2N) 空间复杂度：O(N) 递归反向遍历链表 + 集合转数组

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    private List<Integer> list = new ArrayList<>();
    public int[] reverseBookList(ListNode head) {
        if(head == null){
            // 没有节点时返回new int[0]而不是null
            return new int[0];
        }else if(head.next == null){
            return new int[]{head.val};
        }
        fun(head);
        int[] res = new int[list.size()];
        int i = 0;
        for(int num : list){
            res[i++] = num;
        }
        
        return res;
    }

    public void fun(ListNode head){
        if(head == null){
            return;
        }
        // 当head.next == null时，递归结束，会不断的存放fun(head.next)下面的代码
        fun(head.next);
        list.add(head.val);
    }

}
~~~

解法2：labuladong100%O(N) O(1)递归反向遍历链表并且使用数组存储数据不使用集合

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    private int[] res = null;
    private int i = 0;
    private int len = 0;

    public int[] reverseBookList(ListNode head) {
        // 递归反向遍历链表并且使用数组存储数据不使用集合
        // 思路：递归遍历链表,== null 停止时,指针指向链表的尾部，可在递归的过程中计算链表的长度
        if(head == null){
            return new int[0];
        }else if(head.next == null){
            return new int[]{head.val};
        }
        traverse(head);
        return res;
    }

    public void traverse(ListNode head){
        if(head == null){
            // 到达链表的尾部
            res = new int[len];
            return;
        }
        len++;
        traverse(head.next);
        res[i++] = head.val;
    }
}
~~~

解法3：labuladong栈17% O(n) O(n)

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int[] reverseBookList(ListNode head) {
        // 使用栈解决
        if(head == null){
            return new int[0];
        }else if(head.next == null){
            return new int[]{head.val};
        }
        ListNode p = head;
        Stack<Integer> stack = new Stack<>();
        while(p != null){
            stack.push(p.val);
            p = p.next;
        }
        int[] res = new int[stack.size()];
        int i = 0;
        while(!stack.empty()){
            res[i++] = stack.pop();
        }
        return res;
    }
}
~~~

解法4：labuladong17% 使用递归函数的定义解决，分解的思想，把问题拆分为子问题

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int[] reverseBookList(ListNode head) {
        if(head == null){
            return new int[0];
        }else if(head.next == null){
            return new int[]{head.val};
        }
        List<Integer> list = reverse(head);
        int[] res = new int[list.size()];
        int i = 0;
        for(int num : list){
            res[i++] = num;
        }
        return res;
    }
    // 递归函数的定义：传入链表，返回反向遍历后的集合
    public List<Integer> reverse(ListNode head){
        if(head == null){
            return new LinkedList<Integer>();
        }
        List<Integer> list = reverse(head.next);
        list.add(head.val);
        return list;
    }
}
~~~



## 链表技巧总结

双指针之快慢指针（迭代法）:

1. 快指针先走几步，后面在与慢指针相同速度一起走。
2. 快慢指针一起走，慢指针一次走一步，快指针一次走两步。

例如：

1.  快慢指针  **寻找链表的倒数节点**(算法) 
2.  快慢指针 **寻找链表的中点**  
3.  快慢指针 **判断链表是否包含环**(算法) 
4.  快慢指针 **计算环型链表的入环节点**



单链表常用技巧:

1. **虚拟头结点技巧**：创建一个虚拟头节点dummy，可以方便处理特殊情况与防止空指针，比如要新建一个链表时。

2. **把原链表的节点断开技巧**:如果我们需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，那么断开节点和原链表之间的链接可能是必要的。（养成一个好习惯，但凡遇到这种情况，就把原链表的节点断开，这样就不会出错了。）

   ~~~java
           ListNode head1 = list1;
           ListNode head2 = list2;
           // 要新建一个存储结果的链表，那就创建一个虚拟头节点dummy，每次比较两个排序链表中最小的一个添加到dummy中
           ListNode dummy = new ListNode(-1);
           ListNode p = dummy;
           while(head1 != null && head2 != null){
               if(head1.val <= head2.val){
                   p.next = head1;
                   p = p.next;
                   // 保险起见：断开原链表的连接 head1 = head1.next 替换为下面的3行代码：
                   ListNode temp = head1.next;
                   head1.next = null;
                   head1 = temp;
                   // ps:直接head1 = head1.next然后p.next = null也可以断开原链表的连接
               }else{
                   p.next = head2;
                   p = p.next;
                   // 保险起见：断开原链表的连接
                   ListNode temp = head2.next;
                   head2.next = null;
                   head2 = temp;
               }
           }
   ~~~

   

3. **优先级队列**(二叉堆)PriorityQueue 数据结构的使用

4. 使用递归函数的定义解决，分解为子问题的思想

5. 使用递归的后序遍历位置来解决反向遍历链表的问题

6. 定义变量carry手动模拟加法的进位,对单独的两个链表节点进行加法、进位操作



## 综合运用

### 反转链表（剑指offer,hot100）

https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/?envType=study-plan-v2&envId=coding-interviews

思路：递归反向遍历链表 然后 添加到虚拟头结点创建的链表上 最后断开原链表的连接

解法1：my100% O(N)  O(N)递归的后序遍历

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    // 虚拟头结点
    private ListNode dummy = new ListNode(-1),p = dummy;

    public ListNode trainningPlan(ListNode head) {
        // 思路：递归反向遍历链表 然后 添加到虚拟头结点创建的链表上 最后断开原链表的连接
        if(head == null){
            return null;
        }else if(head.next == null){
            return head;
        }
        traverse(head);
        return dummy.next;
    }
    // 递归反向遍历链表
    public void traverse(ListNode head){
        if(head == null){
            return;
        }
        traverse(head.next);
        p.next = head;
        p = p.next;
        // 断开原链表的连接
        p.next = null;
    }
}
~~~

解法2：labuladong100% 递归分解思想 O(N) O(N)

~~~java
class Solution {
    // 输入链表的头结点，反转整个链表，例如：递归函数接收输入：1->2->3->4 ,head指向1
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            // 处理极端特殊情况，没有节点或者单个节点时直接返回head，符合递归函数的定义
            return head;
        }
        // 递归函数接收输入：2->3->4 ，返回4->3->2<-1 ,last指向4
        ListNode last = reverseList(head.next);
		// 使节点2指向节点1
        head.next.next = head;
		// 置节点1指向null
        head.next = null;
		// 结果：4->3->2->1 ,符合递归函数的定义
        return last;
    }
}
~~~

解法3：迭代（双指针）反转链表 O(N) O(1)

图解：

https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solutions/476929/jian-zhi-offer-24-fan-zhuan-lian-biao-die-dai-di-2/?envType=study-plan-v2&envId=coding-interviews

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode trainningPlan(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        // 初始化两个指针，每次cur都要指向pre
        ListNode cur = head;
        ListNode pre = null;
        while(cur != null){
            // 存储节点，指向存储节点的指针以后肯定要改变了
            ListNode temp = cur.next;
             // 逐个结点反转
            cur.next = pre;
		   // 更新指针位置
            pre = cur;
            cur = temp;
        }
        // cur为null时退出了，pre指向cur的前一个节点，刚刚好是反转后的头节点，直接返回即可
        return pre;
    }
}
~~~



### 深拷贝复杂链表(剑指offer,hot100)

https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/description/?envType=study-plan-v2&envId=coding-interviews

题目就是深拷贝一个链表。

解法1：路人哈希表100%O(N)，O(N)

~~~java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null){
            return null;
        }else if(head.next == null){
            Node res = new Node(head.val);
            res.random = head.random == null ? null : res;
            return res;
        }
        // 建立原节点与新节点的映射关系
        Map<Node,Node> map = new HashMap<>();
        Node p = head;
        while(p != null){
            Node newNode = new Node(p.val);
            map.put(p,newNode);
            p = p.next;
        }
        // 重置p
        p = head;
        // 给新节点的next与random赋值
        while(p != null){
            Node newNode = map.get(p);
            // 坑：map.get(null)会出现问题
            if(p.next != null){
                // 核心：一个新节点的next应该指向的节点 与 原节点的next指向的节点对应的新节点相同
                newNode.next = map.get(p.next);
            }
            if(p.random != null){
                // 核心：一个新节点的random应该指向的节点 与 原节点的random指向的节点对应的新节点相同
                newNode.random = map.get(p.random);
            }
            p = p.next;
        }
        return map.get(head);
    }
}
~~~

解法2:路人详细注释版100% O(N),O(1)空间复杂度 拼接链表 + 拆分链表

~~~java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        // 思路：拼接 + 拆分
        if(head == null){
            return null;
        }else if(head.next == null){
            Node node = new Node(head.val);
            node.random = head.random == null ? null : node;
            return node;
        }
        // 拼接为原节点1->新节点1->原节点2->新节点2 ...的形式
        Node p = head;
        while(p != null){
            // 创建节点并插入
            Node newNode = new Node(p.val);
            newNode.next = p.next;
            p.next = newNode;
            // 移动p
            p = newNode.next;
        }
        // 重置p
        p = head;
        // 给新节点的random指针赋值,新节点的random指针肯定指向新节点，指向哪个新节点呢？回答：指向原节点.random.next这个新节点
        while(p != null && p.next != null){
            if(p.random != null){
                // 注意：是p.next.random而不是p.next.random.next,p.next.random默认为null
                p.next.random = p.random.next;
            }
            p = p.next.next;
        }
        // 重置p
        p = head;
        // 拆分链表
        Node dummy = new Node(-1),cur = dummy;
        while(p != null){
            // 使用新链表连接新节点
            cur.next = p.next;
            cur = cur.next;
            // 记录 + 断开与原链表的连接
            Node temp = cur.next;
            cur.next = null;
            // 恢复原链表
            p.next = temp;
            p = p.next;
        }
        // 最终：head指向原链表，dummy.next指向深拷贝后的新链表
        return dummy.next;

    }
}
~~~

### 链表两数相加(剑指offer，hot100)

注意这个 `carry` 变量的处理，在我们手动模拟加法过程的时候会经常用到。

思路：定义变量carry手动模拟加法的进位,对单独的两个链表节点进行加法、进位操作，使用虚拟头结点存放新的链表。注意循环退出的提交。

解法1：labuladong100% ,手动模拟加法的进位,O(m + n)

~~~java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 在两条链表上的指针
        ListNode p1 = l1, p2 = l2;
        // 虚拟头结点（构建新链表时的常用技巧）
        ListNode dummy = new ListNode(-1);
        // 指针 p 负责构建新链表
        ListNode p = dummy;
        // 记录进位
        int carry = 0;
        // 开始执行加法，两条链表走完且没有进位时才能结束循环
        while (p1 != null || p2 != null || carry > 0) {
            // 先加上上次的进位
            int val = carry;
            if (p1 != null) {
                val += p1.val;
                p1 = p1.next;
            }
            if (p2 != null) {
                val += p2.val;
                p2 = p2.next;
            }
            // 处理进位情况
            carry = val / 10;
            val = val % 10;
            // 构建新节点
            p.next = new ListNode(val);
            p = p.next;
        }
        // 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next;
    }
}
~~~

解法2：my labuladong上面的思路转代码：

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode p1 = l1,p2 = l2;
        // 使用虚拟头节点记录新建的链表
        ListNode dummy = new ListNode(-1),p = dummy;
        // 记录两个数字相加大于9后的进位
        int carry = 0;
        // 只要有一个条件符合则不会退出循环
        // 必须满足对几种情况的处理：l1长度大于l2时对末尾的处理、l2长度大于l1对末尾的处理、链表最后的节点有进位的情况
        while(p1 != null || p2 != null || carry != 0){
            int res = 0;
            int p1Val = p1 == null ? 0 : p1.val;
            int p2Val = p2 == null ? 0: p2.val;
            int newVal = p1Val + p2Val + carry;
            if(newVal >= 10){
                res = newVal % 10;
                carry = 1;
            }else{
                res = newVal;
                carry = 0;
            }
            p.next = new ListNode(res);
            p = p.next;
            if(p1 != null){
                p1 = p1.next;
            }
            if(p2 != null){
                p2 = p2.next;
            }

        }
        return dummy.next;
    }
}
~~~

### 回文链表（hot100）

https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked

解法1：my17% 递归反向遍历链表 O(2N),O(N)

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    private ListNode p = null;
    private boolean res = true;
    public boolean isPalindrome(ListNode head) {
        if(head.next == null){
            return true;
        }
        p = head;
        reverse(head);
        return res;
    }

    public void reverse(ListNode head){
        if(head == null){
            return;
        }
        reverse(head.next);
        if(p.val == head.val){
            p = p.next;
        }else{
            res = false;
        }
    }
}
~~~

解法2：labuladong79% O(N) O(1)

思路：寻找链表的中间节点 + **双指针反转链表** + 回文判断

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    boolean isPalindrome(ListNode head) {
    ListNode slow, fast;
    slow = fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    if (fast != null)
        slow = slow.next;
    
    ListNode left = head;
    ListNode right = reverse(slow);
    while (right != null) {
        if (left.val != right.val)
            return false;
        left = left.next;
        right = right.next;
    }
    
    return true;
}

ListNode reverse(ListNode head) {
    ListNode pre = null, cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}

}
~~~



解法3：labuladong思路转代码 22%O(N) O(N/2)

思路：寻找链表的中间节点 + **递归反转链表** + 回文判断

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head.next == null){
            return true;
        }
        // 寻找链表的中间节点 + 反转链表 + 回文判断
        // 1 寻找链表的中间节点
        ListNode slow = head,fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        // 链表的数量为奇数时，slow指向中间节点，fast不为null，偶数时，slow指向偏右的节点，fast为null
        if(fast != null){
            // 链表的数量为奇数时，让slow统一指向偏右的节点
            slow = slow.next;
        }
        // 2 反转链表
        ListNode reverseListNode = reverse(slow);
        // 3 回文判断
        ListNode right = reverseListNode;
        ListNode left = head;
        while(right != null){
            if(left.val != right.val){
                return false;
            }
            left = left.next;
            right = right.next;
        }
        return true;
    }
    // 反转链表，返回反转后的头节点
    public ListNode reverse(ListNode head){
        // 处理没有节点或者一个节点的情况
        if(head == null || head.next == null){
            return head;
        }
        ListNode node = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return node;
    }
}
~~~

### 排序链表(hot100)

https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked

解法1:路人90% 归并排序链表

详细题解：https://leetcode.cn/problems/sort-list/solutions/13728/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/?envType=study-plan-v2&envId=top-100-liked

思路：寻找一个链表的中心节点后根据中心节点拆分为两个链表 + 使用递归函数的定义进行排序(递归终止时返回一个节点或者null，这时合并两个排序链表相当于对两个节点进行排序...) + 合并两个排序链表

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    // 归并排序？
    // 递归函数的定义：输入链表，返回升序排序后的链表
    public ListNode sortList(ListNode head) {
        // 寻找一个链表的中心节点后根据中心节点拆分为两个链表 + 使用递归函数的定义进行排序(递归终止时返回一个节点或者null，这时合并两个排序链表相当于对两个节点进行排序...) + 合并两个排序链表
        if(head == null || head.next == null){
            return head;
        }
        // 寻找链表的偏左的中心节点
        ListNode fast = head.next,slow = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        // 记录后断开链表
        ListNode temp = slow.next;
        slow.next = null;
        // 递归排序 得到两个有序链表
        ListNode left = sortList(head);
        ListNode right = sortList(temp);
        // 合并两个有序链表
        ListNode dummy = new ListNode(-1),p = dummy;
        while(left != null && right != null){
            if(left.val <= right.val){
                p.next = left;
                left = left.next;
            }else{
                p.next = right;
                right = right.next;
            }
            p = p.next;
            // 断开原链表的连接
            p.next = null;
        }
        p.next = left != null ? left : right;
        return dummy.next;
    }
}
~~~

### 3级 翻转链表(两个一组)

https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&envId=top-100-liked

解法1：labuladong 100% O(N),O(N)使用递归函数的定义解决

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    // 递归函数的定义：输入链表的头节点，返回链表节点两两交换后的头节点
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode first = head;
        ListNode second = head.next;
        ListNode third = head.next.next;
        // 手动解决第一个子问题
        second.next = first;
        // 第一个节点交换后应该指向第三个节点后面的链表交换后返回的节点  后面交给递归来处理
        first.next = swapPairs(third);
        return second;
    }
}
~~~

解法2：官方100%：迭代法 O(N) O(1)

详细图解：

https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/?envType=study-plan-v2&envId=top-100-liked

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(-1),temp = dummy;
        temp.next = head;
        // 有两个节点可以进行交换时就继续循环
        while(temp.next != null && temp.next.next != null){
            ListNode node1 = temp.next;
            ListNode node2 = temp.next.next;
            // 使用字符链表来写出迭代的示意图
            // 初始：temp -> node1 -> node2 -> ?
            temp.next = node2; // temp,node1 -> node2 -> ?
            node1.next = node2.next;// temp -> node2 node1 -> ?
            node2.next = node1;// temp -> node2 -> node1 -> ?
            temp = node1; // node2 -> node1,temp -> ?
        }
        return dummy.next;

    }
}
~~~

### 翻转链表(k个一组)

递归函数的定义，分解的思想来解决问题时：要自己先完成其中一个子问题的大部分问题(如：base case指定递归退出条件、核心的操作)，剩下的一部分和剩下的子问题交给递归去完成。

**前置基础**：给定a,b两个链表节点，反转[a,b)这个区间的链表

解法1：labuladong100% O(N) O(N/k) 递归分解思想 + 反转链表

~~~java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */、
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null || head.next == null){
            return head;
        }
        // 为了解决完整的问题，先解决一个子问题：反转从头到第k个节点，即：第一组的链表
        ListNode a = head,b = head;
        for(int i = 0;i < k;i++){
            // 如果提前退出for循环，表示链表节点的数量少与k个,反转的结果与不反转相同，直接返回即可 base case
            if(b == null){
                return head;
            }
            b = b.next;
        }
        ListNode newHead = reverse(a,b);
        a.next = reverseKGroup(b,k);
        return newHead;
    }
    // 反转区间[节点a,节点b)内的所有链表节点
    public ListNode reverse(ListNode a,ListNode b){
        ListNode temp = null,cur = a,pre = null;
        while(cur != b){
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
~~~

解法2：迭代

~~~java
~~~



## 待定

### 反转字符串中的单词

https://leetcode.cn/problems/reverse-words-in-a-string/description/

解法1：my O(n) 57% 使用StringBuilder类处理字符串，O(n)空间复杂度

~~~java
class Solution {
    public String reverseWords(String s) {
        if(" ".equals(s)){
            return "";
        }else if(s.length() == 1){
            return s;
        }
        // 去除前后多余的空格
        s = s.trim();
        //去除中间多余的空格
        StringBuilder sb = new StringBuilder();
        for(int i = 0;i < s.length();i++){
            char c = s.charAt(i);
            if(c != ' '){
                sb.append(c);
            }else if(sb.charAt(sb.length() - 1) != ' '){
                sb.append(c);
            }
        }
        // 把整个字符串反转
        reverse(sb,0,sb.length() - 1);
        // 快慢指针：把每一个单词单独反转。 快指针在前面探路的写法
        int slow = 0;
        for(int fast = 1;fast <= sb.length();fast++){
            if(fast == sb.length() || sb.charAt(fast) == ' '){
                reverse(sb,slow,fast-1);
                slow = fast + 1;
            }
        }
        return sb.toString();
    }
    // 反转索引 left-right的字符串
    public void reverse(StringBuilder sb,int left,int right){
        while(left < right){
            char temp = sb.charAt(left);
            sb.setCharAt(left,sb.charAt(right));
            sb.setCharAt(right,temp);
            left++;
            right--;
        }
    }
}
~~~

解法2：my 使用split(" ")分隔字符串配合StringBuilder()

~~~java
class Solution {
    public String reverseWords(String s) {
        if(" ".equals(s)){
            return "";
        }else if(s.length() == 1){
            return s;
        }
        // 去除前后多余的空格
        s = s.trim();
        //去除中间多余的空格
        StringBuilder sb = new StringBuilder();
        for(int i = 0;i < s.length();i++){
            char c = s.charAt(i);
            if(c != ' '){
                sb.append(c);
            }else if(sb.charAt(sb.length() - 1) != ' '){
                sb.append(c);
            }
        }
        s = sb.toString();
        String[] strs = s.split(" ");
        StringBuilder sb1 = new StringBuilder();
        // 从后往前遍历
        for(int i = strs.length - 1;i >= 0;i--){
            sb1.append(strs[i]);
            if(i != 0){
                sb1.append(" ");
            }
            
        }
        return sb1.toString();
    }
    
}
~~~

### 反转字符串中的单词 剑指offer

https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/description/

解法1：路人100% api大法:trim(),split()

~~~java
class Solution {
    public String reverseMessage(String message) {
        String[] tmp = message.trim().split(" ");
        StringBuffer sb = new StringBuffer();
        for(int i=tmp.length-1;i>=0;i--){
            if(tmp[i] !=""){
                sb.append(tmp[i]+" ");
            }
        }
        return sb.toString().trim();
    }
}
~~~

解法2:my5% 不使用trim()、split()等方法，自己来实现

~~~java
class Solution {
    public String reverseMessage(String message) {
        if(message.length() == 0){
            return message;
        }
        // 去除空格
        StringBuilder sb = removeSpace(message);
        int len = sb.length();
        if(len == 0){
            return sb.toString();
        }
        // 反转全部字符
        reverse(sb,0,len - 1);
        //反转每一个单词
        int slow = 0;
        for(int fast = 1;fast <= len;fast++){
            // 反转结尾的单词 与 每一个空格前的单词
            if(fast == len || sb.charAt(fast) == ' '){
                reverse(sb,slow,fast - 1);
                slow = fast + 1;
            }
        }
        return sb.toString();
    }

    public StringBuilder removeSpace(String message){
        StringBuilder sb = new StringBuilder(message);
        StringBuilder res = new StringBuilder();
        // 去除前后的空格 实现trim()方法
        while(sb.length() > 0 && sb.charAt(0) == ' '){
            // 注意：删除操作后字符的索引会重新排列,所以sb.charAt(0)的值在改变
            sb.deleteCharAt(0);
        }
        if(sb.length() == 0){
            return res;
        }
        while(sb.charAt(sb.length() - 1) == ' '){
            sb.deleteCharAt(sb.length() - 1);
        }
        
        // 去除中间多余的空格
        for(int i = 0;i < sb.length();i++){
            char c = sb.charAt(i);
            if( c != ' '){
                res.append(c);
            }else if(res.charAt(res.length() - 1) != ' '){
                res.append(c);
            }
        }
        return res;
    }

    public void reverse(StringBuilder sb,int left,int right){
        while(left < right){
            char temp = sb.charAt(left);
            sb.setCharAt(left,sb.charAt(right));
            sb.setCharAt(right,temp);
            left++;
            right--;
        }
    }
}
~~~





